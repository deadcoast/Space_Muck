# [GALACTIC_SPRAWL] CODEBASE DOCUMENTATION

This documentation uses specialized hashtag identifiers (#system_name) as navigation anchors throughout the codebase documentation. These identifiers serve as precise locators for system-specific information. For example, when you need details about the resource system, search for "#resource_system" to immediately access the complete documentation for that particular system.

## .windsurfrules IMPLEMENTATION REQUIREMENTS

1. Upon accessing this template, conduct a comprehensive codebase analysis to extract the structural information specified in each section.

2. Replace each comment placeholder with concrete content derived directly from codebase analysis—maintain fidelity to actual implementations.

3. Prioritize extraction of implementation-specific details: class/interface definitions, design patterns, method signatures, and representative code examples.

4. Maintain strict adherence to ASCII Directory Tree diagram formatting when documenting hierarchical relationships.

5. Include focused code snippets that demonstrate actual implementation patterns rather than theoretical examples.

6. Remove any sections that lack corresponding implementations in the codebase under analysis.

7. Extend documentation with additional system-specific sections when discovering undocumented subsystems.

8. Emphasize structural clarity over verbose explanations—let code organization and implementation patterns serve as primary documentation.

9. Preserve all hashtag section identifiers (#system_name) in their exact format as they function as critical search anchors.

10. Focus documentation on architectural components and patterns that directly facilitate understanding the system design and implementing compatible features.

## System Navigation via Hashtag Identifiers:
When investigating specific systems, use these standardized hashtags within `.windsurfcontext` to locate relevant documentation.

## TABLE OF CONTENTS

### Core Game Systems
- [Executive Summary](#executive_summary) - High-level overview of the architecture
- [Event System](#event_system) - Event handling and subscription patterns
- [Resource System](#resource_system) - Resource management and types
- [Module System](#module_system) - Module architecture and lifecycle
- [Component System](#component_system) - Component registration patterns
- [Type System](#type_system) - Type safety patterns and guards
- [Manager System](#manager_system) - Manager interfaces and implementations
- [Context System](#context_system) - Context providers and state management
- [Exploration System](#exploration_system) - Exploration system architecture

### Game Logic Systems
- [State System](#state_system) - Game state transitions and validation
- [Ship System](#ship_system) - Ship components and combat mechanics
- [AI System](#ai_system) - AI agent structure and behavior patterns
- [Dependency Injection System](#dependency_system) - Service container implementation

### Technical Systems
- [Testing System](#testing_system) - Testing patterns and frameworks
- [Performance System](#performance_system) - Performance optimization techniques
- [UI System](#ui_system) - User interface components and patterns

### Support Systems
- [Error Fixes](#error_fixes) - Common errors and solutions

## EXECUTIVE SUMMARY (#executive_summary)

Space Muck is a procedurally generated space exploration game built with Python and Pygame. The architecture follows a modular, component-based design with several interconnected systems that manage various aspects of gameplay.

### Core Architectural Principles

1. **Entity-Component Design**: The game uses a flexible entity system where all game objects inherit from `BaseEntity`, with specialized entities for different game elements.

2. **Procedural Generation**: Leverages layered algorithms including cellular automata, noise maps, and rule-based systems to generate diverse content dynamically.

3. **Context-Based State Management**: Game state is managed through context providers that coordinate communication between systems and handle state transitions.

4. **Event-Driven Communication**: Systems communicate through a decentralized event system with a subscriber model, allowing for loose coupling.

5. **Module-Based Organization**: Functionality is organized into distinct modules with clear responsibilities and minimal dependencies.

### Key System Relationships

SYSTEM RELATIONSHIPS
Entity System <-> Context Providers <-> Event System
UI Components <-> Manager Systems <-> Resource System
Procedural Gen <-> Exploration System

### Mock Data Generation Patterns

```python
from tests.tools.mock_data_test import (
    create_mock_field_data,
    create_mock_race,
    create_mock_shop_upgrade,
    _create_asteroid_clusters,
    _create_rare_grid,
    _create_energy_grid,
    _create_entity_grid,
    _add_circular_cluster,
)

def create_mock_field_data(width=100, height=80, complexity=0.5):
    """Create mock field data for testing."""
    # Generate the asteroid grid with clusters
    grid = _create_asteroid_clusters(width, height)
    
    # Generate the rare minerals grid
    rare_grid, rare_positions = _create_rare_grid(width, height)
    
    # Generate the energy grid
    energy_grid, energy_positions = _create_energy_grid(width, height)
    
    # Generate the entity grid
    entity_grid, entities = _create_entity_grid(width, height)
    
    return {
        "grid": grid,
        "rare_grid": rare_grid,
        "rare_positions": rare_positions,
        "energy_grid": energy_grid,
        "energy_positions": energy_positions,
        "entity_grid": entity_grid,
        "entities": entities,
        "complexity": complexity,
    }
```

### Test Verification Patterns

```python
def test_inheritance_hierarchy(self):
    """Test the inheritance hierarchy using real implementations."""
    # Create instances of each class in the hierarchy
    base_entity = BaseEntity()
    miner_entity = MinerEntity()
    player_entity = PlayerEntity()
    
    # Verify inheritance relationships
    self.assertIsInstance(base_entity, BaseEntity)
    self.assertIsInstance(miner_entity, BaseEntity)
    self.assertIsInstance(player_entity, BaseEntity)
    self.assertIsInstance(player_entity, MinerEntity)
    
    # Verify each level adds its specific attributes
    self.assertTrue(hasattr(base_entity, "entity_id"))
    self.assertTrue(hasattr(base_entity, "entity_type"))
    
    self.assertTrue(hasattr(miner_entity, "race_id"))
    self.assertEqual(miner_entity.trait, "standard")
    
    self.assertTrue(hasattr(player_entity, "is_player"))
    self.assertEqual(player_entity.trait, "adaptive")
    
    # Verify that the inheritance chain preserves base functionality
    self.assertEqual(player_entity.entity_type, "miner")
    self.assertEqual(player_entity.color, (0, 255, 255))
```

### Integration Test Patterns

```python
class TestFixersIntegration(unittest.TestCase):
    """Test the integration of the fixers module with other modules."""

    def setUp(self):
        """Set up the test environment."""
        # Skip tests if dependencies aren't available
        if not CORE_AVAILABLE:
            self.skipTest("Core module not available")
            
        # Mock dependencies as needed
        self.patch_log_context = mock.patch("python_fixer.utils.logging.LogContext")
        self.mock_log_context = self.patch_log_context.start()
        self._setup_log_context_mock(self.mock_log_context)
        
        # Import modules only during test setup to handle optional dependencies
        if CORE_AVAILABLE:
            from python_fixer.core import FixManager
            self.fix_manager_class = FixManager

    def tearDown(self):
        """Clean up the test environment."""
        # Stop all patches
        mock.patch.stopall()

    def test_no_circular_dependencies(self):
        """Test that there are no circular dependencies between modules."""
        self._verify_no_circular_imports()
```

### Optional Dependency Handling

```python
# Define module-level variables for optional dependencies
git = None
black = None
isort = None
libcst = None
networkx = None
numpy = None
scipy = None
sklearn = None
rope = None

# Check for optional dependencies
GIT_AVAILABLE = importlib.util.find_spec("git") is not None
BLACK_AVAILABLE = importlib.util.find_spec("black") is not None
ISORT_AVAILABLE = importlib.util.find_spec("isort") is not None
LIBCST_AVAILABLE = importlib.util.find_spec("libcst") is not None
NETWORKX_AVAILABLE = importlib.util.find_spec("networkx") is not None
NUMPY_AVAILABLE = importlib.util.find_spec("numpy") is not None
SCIPY_AVAILABLE = importlib.util.find_spec("scipy") is not None
SKLEARN_AVAILABLE = importlib.util.find_spec("sklearn") is not None
ROPE_AVAILABLE = importlib.util.find_spec("rope") is not None

# Only import if available to prevent ImportError
if numpy_available:
    import numpy as np
    
# Skip tests that require optional dependencies
def test_integration_with_numpy(self):
    """Test integration with numpy."""
    if not NUMPY_AVAILABLE:
        self.skipTest("NumPy not installed")
    # Test implementation...
```

### Test Import Verification System

```python
def run_tests():
    """Run comprehensive import verification tests."""
    print("\nRunning import verification tests...")
    
    # Core functionality imports
    modules_to_check = [
        "entities.base_entity",
        "entities.player",
        "generators.base_generator",
        "generators.asteroid_field",
        "systems.game",
        "ui.ascii_base",
    ]
    
    results = {}
    for module_name in modules_to_check:
        try:
            # Attempt to dynamically import and reload the module
            if module_name in sys.modules:
                module = sys.modules[module_name]
                importlib.reload(module)
            else:
                module = importlib.import_module(module_name)
                
            # Try to instantiate a class or function from the module
            # to verify deeper functionality
            verify_deeper_functionality(module)
                
            results[module_name] = "OK"
        except Exception as e:
            results[module_name] = f"FAILED: {str(e)}"
    
    # Print verification results
    print("\nImport verification results:")
    for module_name, status in results.items():
        status_color = "\033[92m" if status == "OK" else "\033[91m"  # Green or red
        print(f"{status_color}{module_name}: {status}\033[0m")
    
    return all(status == "OK" for status in results.values())
```
```
+----------------+      +--------------------+      +----------------+
|                |      |                    |      |                |
| Entity System  <----->+ Context Providers  <----->+ Event System   |
|                |      |                    |      |                |
+-------^--------+      +---------^----------+      +-------^--------+
        |                        |                         |
        |                        |                         |
        v                        v                         v
+----------------+      +--------------------+      +----------------+
|                |      |                    |      |                |
| UI Components  <----->+ Manager Systems    <----->+ Resource System|
|                |      |                    |      |                |
+-------^--------+      +---------^----------+      +----------------+
        |                        |                         
        |                        |                         
        v                        v                         
+----------------+      +--------------------+      
|                |      |                    |      
| Procedural Gen <----->+ Exploration System |      
|                |      |                    |      
+----------------+      +--------------------+      
```

### Technology Stack

- **Core Engine**: Python with Pygame for rendering
- **Data Structures**: NumPy for efficient array operations
- **Algorithms**: Custom implementations of procedural generation algorithms
- **Testing**: Python's unittest framework with custom performance benchmarks
- **UI**: Custom ASCII-based component system

### Performance Optimization Approach

The codebase employs targeted optimizations including:
- Spatial partitioning for entity interactions
- Batch processing for entity updates
- Lazy loading and evaluation patterns
- Performance monitoring through detailed logging

### Documentation Organization

This document is organized by system, with each section identified by a hashtag (e.g., `#event_system`). Each section contains:
- System overview and purpose
- Core interfaces and implementations
- Integration patterns with other systems
- Code examples demonstrating typical usage

## CODEBASE OVERVIEW

Space_Muck is a game with a modular architecture featuring multiple interacting systems:

- Core game loop and state management (main.py, game.py)
- Entity system with hierarchy (entities/)
- UI components and events (ui/)
- Resource and module management (systems/)
- Procedural generation (generators/)
- Various utilities and helpers (utils/)

The codebase follows a component-based design with managers for different subsystems, event-driven communication, and optional dependencies for performance features.

## SYSTEM ARCHITECTURE

Game
├── ResourceManager
│   └── ResourceFlow
├── ModuleManager
│   └── ModuleInterface
├── ExplorationManager
└── FleetManager
    └── Fleet

EventSystem
├── EventBus (default)
└── ComponentEventBridge

UISystem
├── UIElement
│   ├── ASCIIBox
│   ├── ASCIIPanel
│   └── ASCIIButton
└── ComponentRegistry

## COMPONENT ARCHITECTURE
<!-- 
Analyze the codebase for major component categories.
Identify relationship hierarchies between components.
Create an ASCII hierarchy diagram showing these relationships.
Example:

ContextProviders
├── GameContext
├── ResourceRatesContext
└── ThresholdContext

EventBuses
├── ModuleEventBus
└── GameEventBus
-->

## LOCAL IMPORT DIRECTORY (#local_imports)

This section documents the import patterns and dependencies across the Space Muck codebase, providing a map of module relationships and standard practices.

### STANDARD IMPORT PATTERNS

```python
# Standard pattern: Import standard libraries first
import logging
import random
import uuid

# Then import typing annotations
from typing import Any, Dict, List, Optional, Set, Tuple

# Then third-party libraries
import numpy as np
import pygame

# Then local absolute imports from other packages
from algorithms.symbiote_algorithm import SymbioteEvolutionAlgorithm
from entities.base_entity import BaseEntity
from utils.logging_setup import log_exception

# Then configuration imports
from config import CELL_SIZE, DEBUG_MODE

# Finally, relative imports within the same package
from .submodule import Component
```

### CORE SYSTEM IMPORTS

#### ENTITY SYSTEM

MODULE: src/entities/base_entity.py
IMPORTED BY:
- src/entities/miner_entity.py
  `from entities.base_entity import BaseEntity`
- src/generators/base_generator.py
  `from entities.base_entity import BaseEntity`
- src/utils/import_standards.py
  `from entities.base_entity import BaseEntity`
- src/tests/test_base_entity.py
  `from entities.base_entity import BaseEntity`
- src/tests/test_fleet.py
  `from entities.base_entity import BaseEntity`

RELATIVE IMPORTS:
- src/entities/fleet.py
  `from .base_entity import BaseEntity`
- src/entities/enemy_ship.py
  `from .base_entity import BaseEntity`

#### PROCEDURAL GENERATION SYSTEM

MODULE: src/generators/base_generator.py
IMPORTED BY:
- src/generators/procedural_generator.py
  `from generators.base_generator import BaseGenerator`
- src/generators/asteroid_generator.py
  `from generators.base_generator import BaseGenerator`
- src/generators/symbiote_evolution_generator.py
  `from generators.base_generator import BaseGenerator`
- src/tests/test_base_generator.py
  `from generators.base_generator import BaseGenerator`

MODULE: src/utils/dependency_injection.py
IMPORTED BY:
- src/generators/symbiote_evolution_generator.py
  `from utils.dependency_injection import inject`
- src/generators/procedural_generator.py
  `from utils.dependency_injection import inject`
- src/generators/asteroid_generator.py
  `from utils.dependency_injection import inject`
- src/generators/base_generator.py
  `from utils.dependency_injection import inject`

#### SYSTEMS MODULES

MODULE: src/systems/combat_system.py
IMPORTED BY:
- src/main.py
  `from systems.combat_system import CombatSystem`
- src/generators/encounter_generator.py
  `from systems.combat_system import CombatSystem`
- src/systems/encounter_generator.py
  `from systems.combat_system import CombatSystem`
- src/tests/tools/test_combat_system.py
  `from systems.combat_system import CombatSystem`

MODULE: src/systems/event_system.py
IMPORTED BY:
- src/main.py
  `from systems.event_system import get_event_batcher`

MODULE: src/systems/game_loop.py
IMPORTED BY:
- src/main.py
  `from systems.game_loop import get_game_loop`

#### UI COMPONENT SYSTEM

MODULE: src/ui/ui_base/ascii_base.py
IMPORTED BY:
- src/demos/ascii_ship_status_panel_demo.py
  `from ui.ui_base.ascii_base import UIStyle`
- src/demos/ascii_crew_management_panel_demo.py
  `from ui.ui_base.ascii_base import UIStyle`
- src/demos/ascii_inventory_panel_demo.py
  `from ui.ui_base.ascii_base import UIStyle`

MODULE: src/ui/ui_element/ascii_box.py
IMPORTED BY:
- src/demos/ascii_box_event_demo.py
  `from ui.ui_element.ascii_box import ASCIIBox`

MODULE: src/ui/ui_base/event_system.py
IMPORTED BY:
- src/demos/ascii_box_event_demo.py
  `from ui.ui_base.event_system import UIEventData, UIEventType`
- src/ui/ui_element/ascii_box.py (conditional import)
  `from ui.ui_base.event_system import UIEventSystem`

### CIRCULAR DEPENDENCY MITIGATIONS

```python
# In src/ui/__init__.py
# Do not import ui_element modules here to avoid circular dependencies

# In src/ui/ui_element/ascii_box.py - conditional imports to avoid circular dependencies
if needs_event_handling:
    from ui.ui_base.event_system import UIEventSystem
    from ui.ui_helpers.event_integration import is_registered_with_events
```

### MODULAR IMPORT STRATEGY

The UI components follow a particularly strict modular import strategy:

```python
# Base classes and enums
from ui.ui_base.ascii_base import UIStyle, UIElement

# Component implementations
from ui.ui_element.ascii_box import ASCIIBox
from ui.ui_element.ascii_panel import ASCIIPanel

# Helper utilities
from ui.ui_helpers.ascii_box_event_helper import register_for_events
```

### BARREL IMPORT FILES

The main module `__init__.py` files are kept minimal to avoid circular dependencies, especially in the UI system. Key components are exported selectively:

```python
# In src/ui/__init__.py
# Only export core items needed, not full implementations
from .ui_base.ascii_base import UIStyle, UIElement

# Do not import ui_element modules here to avoid circular dependencies
```

### LAZY IMPORTS

Several modules use lazy/conditional imports to improve startup time and avoid circular dependencies:

```python
# In src/main.py - conditional imports for specific game states
if game_state == GameState.PLAYING:
    from ui.game_screen import ASCIIGameScreen
    from ui.minimap_panel import ASCIIMinimapPanel
```

## EVENT SYSTEM (#event_system)

```python
class EventBus:
    """Event bus for handling game events."""

    def __init__(self, name: str):
        self.name = name
        self._subscribers: Dict[str, List[Callable]] = defaultdict(list)
        self._event_history: List[Dict[str, Any]] = []
        self._max_history = 100  # Maximum number of events to track

    def subscribe(self, event_type: str, callback: Callable) -> None:
        """Subscribe to an event type."""
        if callback not in self._subscribers[event_type]:
            self._subscribers[event_type].append(callback)

    def publish(self, event_type: str, data: Any = None) -> None:
        """Publish an event to all subscribers."""
        event = {
            "type": event_type,
            "data": data,
            "timestamp": time.time(),
        }
        
        # Record in history
        self._event_history.append(event)
        if len(self._event_history) > self._max_history:
            self._event_history.pop(0)
            
        # Call subscribers
        for callback in self._subscribers[event_type]:
            try:
                callback(event)
            except Exception as e:
                logger.error(f"Error in event handler: {e}")
```

### Event Type Guards

```python
def is_resource_event(event: Dict[str, Any]) -> bool:
    """Type guard for resource events."""
    return event["type"].startswith("RESOURCE_") and "resource_id" in event["data"]

def is_module_event(event: Dict[str, Any]) -> bool:
    """Type guard for module events."""
    return event["type"].startswith("MODULE_") and "module_id" in event["data"]
```

### Event Bus Registry

```python
# Global event bus registry
_event_buses: Dict[str, EventBus] = {}

def get_event_bus(name: str = "default") -> EventBus:
    """Get or create an event bus."""
    if name not in _event_buses:
        _event_buses[name] = EventBus(name)
    return _event_buses[name]

def clear_event_buses() -> None:
    """Clear all event buses. Useful for testing."""
    _event_buses.clear()
```

## RESOURCE SYSTEM (#resource_system)

### Core Types and States

```python
class ResourceType(Enum):
    ENERGY = auto()
    MATTER = auto()
    FLUID = auto()
    DATA = auto()


# Resource States
class ResourceState(Enum):
    STABLE = auto()
    DEPLETING = auto()
    GROWING = auto()
    CRITICAL = auto()


# Resource Flow Patterns
FLOW_PATTERNS = {
    "direct": "One-to-one resource transfer",
    "split": "One-to-many resource distribution",
    "merge": "Many-to-one resource collection",
    "cycle": "Circular resource flow pattern",
}

# Resource Thresholds
RESOURCE_THRESHOLDS = {
    "critical_low": 0.1,  # 10% of capacity
    "low": 0.25,  # 25% of capacity
    "optimal": 0.75,  # 75% of capacity
    "high": 0.9,  # 90% of capacity
}


@dataclass
class ResourceFlow:
    """Represents a flow of resources between nodes."""
    source_id: str
    dest_id: str
    resource_type: ResourceType
    rate: float
    priority: int = 1
    active: bool = True
```

### ResourceManager Implementation

```python
class ResourceManager:
    """Central manager for handling all resource-related operations."""

    def __init__(self) -> None:
        """Initialize the resource manager."""
        # Resource tracking
        self.resources: Dict[str, Dict[ResourceType, float]] = {}
        self.capacities: Dict[str, Dict[ResourceType, float]] = {}
        self.states: Dict[str, Dict[ResourceType, ResourceState]] = {}
        
        # Flow management
        self.flows: List[ResourceFlow] = []
        self.flow_history: Dict[str, List[Tuple[float, float]]] = {}  # (timestamp, amount)
        
        # System state
        self.active = True
        self.paused = False
        self.update_interval = 1.0  # seconds
        self.last_update = 0.0

    def register_resource_node(
            self,
            node_id: str,
            resource_types: Dict[ResourceType, float],
            capacities: Optional[Dict[ResourceType, float]] = None,
        ) -> bool:
        """Register a new resource node in the system."""
        # Implementation details...
        
    def add_resource_flow(
            self,
            source_id: str,
            dest_id: str,
            resource_type: ResourceType,
            rate: float,
            priority: int = 1,
        ) -> bool:
        """Add a new resource flow between nodes."""
        # Implementation details...
        
    def update(self, dt: float) -> None:
        """Update resource states and process flows."""
        if not self._should_update(dt):
            return
            
        self.last_update += dt
        self._process_active_flows()
        self._update_resource_states()
```

## MODULE SYSTEM (#module_system)

### Core Types and States

```python
# Module States
class ModuleState(Enum):
    UNINITIALIZED = auto()
    INITIALIZING = auto()
    ACTIVE = auto()
    PAUSED = auto()
    ERROR = auto()
    SHUTTING_DOWN = auto()
    TERMINATED = auto()


# Module Categories
class ModuleCategory(Enum):
    CORE = auto()  # Essential system modules
    RESOURCE = auto()  # Resource handling modules
    PRODUCTION = auto()  # Production and crafting modules
    RESEARCH = auto()  # Research and development modules
    EXPLORATION = auto()  # Exploration and discovery modules
    UI = auto()  # User interface modules
    UTILITY = auto()  # Helper and utility modules


# Module Dependencies
@dataclass
class ModuleDependency:
    """Represents a module's dependency on another module."""
    module_id: str
    required: bool = True
    min_version: Optional[str] = None
    max_version: Optional[str] = None


@dataclass
class ModuleConfig:
    """Configuration settings for a module."""
    update_interval: float = 1.0
    auto_start: bool = True
    priority: int = 1
    category: ModuleCategory = ModuleCategory.UTILITY
```

### Module Interface

```python
class ModuleInterface:
    """Base interface that all modules must implement."""

    def initialize(self) -> bool:
        """Initialize the module."""
        raise NotImplementedError("Modules must implement initialize()")

    def update(self, dt: float) -> None:
        """Update module state."""
        raise NotImplementedError("Modules must implement update()")

    def pause(self) -> bool:
        """Pause module operations."""
        raise NotImplementedError("Modules must implement pause()")

    def resume(self) -> bool:
        """Resume module operations."""
        raise NotImplementedError("Modules must implement resume()")

    def shutdown(self) -> bool:
        """Shutdown the module."""
        raise NotImplementedError("Modules must implement shutdown()")
```

### ModuleManager Implementation

```python
class ModuleManager:
    """Central manager for handling all module-related operations."""

    def __init__(self) -> None:
        """Initialize the module manager."""
        # Module tracking
        self.modules: Dict[str, ModuleInterface] = {}
        self.states: Dict[str, ModuleState] = {}
        self.configs: Dict[str, ModuleConfig] = {}
        self.dependencies: Dict[str, List[ModuleDependency]] = {}
        
        # Update tracking
        self.update_times: Dict[str, float] = {}
        self.error_counts: Dict[str, int] = {}
        self.max_errors = 3  # Maximum errors before disabling a module
        
        # System state
        self.active = True
        self.paused = False
        
        # Event handlers
        self.on_module_state_change: Dict[str, List[Callable[[ModuleState], None]]] = {}

    def register_module(
            self,
            module_id: str,
            module: ModuleInterface,
            config: Optional[ModuleConfig] = None,
            dependencies: Optional[List[ModuleDependency]] = None,
        ) -> bool:
        """Register a new module with the system."""
        # Implementation details...
        
    def start_module(self, module_id: str) -> bool:
        """Start a module."""
        # Implementation details...
        
    def update(self, dt: float) -> None:
        """Update all active modules."""
        if not self.active or self.paused:
            return
            
        for module_id, module in self.modules.items():
            if self.states.get(module_id) == ModuleState.ACTIVE:
                try:
                    module.update(dt)
                    self.update_times[module_id] = time.time()
                except Exception as e:
                    self._handle_module_error(module_id, e)
```

## COMPONENT REGISTRATION SYSTEM (#component_system)

### Component States and Registry

```python
class ComponentState(Enum):
    """Possible states of a UI component in the registry."""
    CREATED = auto()      # Component has been created but not initialized
    INITIALIZED = auto()  # Component has been initialized
    ACTIVE = auto()       # Component is active and visible
    INACTIVE = auto()     # Component exists but is not currently visible
    DISABLED = auto()     # Component exists but is disabled from interaction
    DESTROYED = auto()    # Component is marked for removal


class ComponentRegistry:
    """Registry for UI components with lifecycle management."""

    # Singleton instance
    _instance = None

    @classmethod
    def get_instance(cls) -> "ComponentRegistry":
        """Get the singleton instance of the registry."""
        if cls._instance is None:
            cls._instance = ComponentRegistry()
        return cls._instance

    def __init__(self):
        """Initialize the component registry."""
        # Component tracking
        self.components: Dict[str, weakref.ReferenceType[UIElement]] = {}
        self.states: Dict[str, ComponentState] = {}
        self.types: Dict[str, str] = {}  # component_id -> type_name
        
        # Type registration
        self.registered_types: Dict[str, Type[UIElement]] = {}
        
        # Event subscriptions
        self.subscriptions: Dict[str, Set[str]] = {}  # component_id -> event_types
        
        # Hierarchy tracking
        self.parents: Dict[str, Optional[str]] = {}  # component_id -> parent_id
        self.children: Dict[str, Set[str]] = defaultdict(set)  # parent_id -> child_ids
```

### Component Registration Pattern

```python
def register_component(component: UIElement, component_type: str) -> str:
    """Register a component with the registry and return its ID.
    
    Args:
        component: The component to register
        component_type: The type name for this component
        
    Returns:
        str: The unique ID assigned to this component
    """
    registry = ComponentRegistry.get_instance()
    component_id = f"{component_type}_{uuid.uuid4().hex[:8]}"
    
    # Store weak reference to avoid memory leaks
    registry.components[component_id] = weakref.ref(component)
    registry.states[component_id] = ComponentState.CREATED
    registry.types[component_id] = component_type
    
    return component_id


def register_event_subscriptions(component_id: str, event_types: List[str]) -> None:
    """Register event subscriptions for a component.
    
    Args:
        component_id: The component ID to subscribe events for
        event_types: List of event types to subscribe to
    """
    registry = ComponentRegistry.get_instance()
    if component_id in registry.components:
        registry.subscriptions[component_id] = set(event_types)
```

### Component Hierarchy Management

```python
def set_component_parent(child_id: str, parent_id: Optional[str]) -> bool:
    """Set the parent relationship for a component.
    
    Args:
        child_id: The component to set the parent for
        parent_id: The parent component ID, or None to remove parent
        
    Returns:
        bool: True if successful, False otherwise
    """
    registry = ComponentRegistry.get_instance()
    
    # Remove from previous parent's children if exists
    previous_parent = registry.parents.get(child_id)
    if previous_parent:
        registry.children[previous_parent].discard(child_id)
    
    # Set new parent relationship
    registry.parents[child_id] = parent_id
    
    # Add to new parent's children if parent exists
    if parent_id:
        registry.children[parent_id].add(child_id)
        
    return True
```

## UI SYSTEM (#ui_system)

### Core UI Architecture

```python
# Base UI Classes (in ascii_base.py)
class UIStyle(Enum):
    """Enum for UI visual styles."""
    SYMBIOTIC = auto()  # Organic, flowing style
    ASTEROID = auto()   # Rocky, rough style
    MECHANICAL = auto() # Industrial, mechanical style
    QUANTUM = auto()    # High-tech, digital style
    FLEET = auto()      # Military, utilitarian style
    
    @classmethod
    def get_border_chars(cls, style: "UIStyle") -> Dict[str, str]:
        """Get border characters for the specified UI style."""
        # Implementation details...


class AnimationStyle(Enum):
    """Enum for animation styles."""
    NONE = auto()
    FADE_IN = auto()
    FADE_OUT = auto()
    SLIDE_IN = auto()
    SLIDE_OUT = auto()
    PULSE = auto()
    BLINK = auto()
    
    @classmethod
    def get_animation_style(cls, ui_style: UIStyle) -> "AnimationStyle":
        """Get the appropriate animation style for a UI style."""
        # Implementation details...


class UIElement:
    """Base class for all UI elements."""
    
    def __init__(self, x: int, y: int, width: int, height: int, style: UIStyle, title: Optional[str] = None):
        """Initialize a UI element."""
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.style = style
        self.title = title
        self.visible = True
        self.hover = False
        
        # Animation state
        self.animation = {
            "active": False,
            "style": AnimationStyle.NONE,
            "progress": 0.0,
            "duration": 0.0,
            "start_time": 0.0,
        }
        
        # Initialize border characters based on style
        self.border_chars = UIStyle.get_border_chars(style)
```

### UI Component Implementation 

```python
# UI Components (in ascii_ui.py, max 200 lines per file)
class ASCIIBox(UIElement):
    """A simple box UI element."""
    
    def __init__(self, x: int, y: int, width: int, height: int, style: UIStyle, title: Optional[str] = None):
        """Initialize an ASCII box."""
        super().__init__(x, y, width, height, style, title)
    
    def draw(self, surface: pygame.Surface, font: pygame.font.Font) -> None:
        """Draw the box."""
        if not self.visible:
            return
            
        # Draw border
        self._draw_border(surface, font)
        
        # Draw title if present
        if self.title:
            self._draw_title(surface, font)


class ASCIIPanel(UIElement):
    """A panel that can contain text content."""
    
    def __init__(self, x: int, y: int, width: int, height: int, style: UIStyle, title: Optional[str] = None):
        """Initialize an ASCII panel."""
        super().__init__(x, y, width, height, style, title)
        self.content = ""
        
    def set_content(self, content: str) -> None:
        """Set the panel content."""
        self.content = content
        
    def draw(self, surface: pygame.Surface, font: pygame.font.Font) -> None:
        """Draw the panel with its content."""
        # First draw the base box
        super().draw(surface, font)
        
        # Then draw the content
        if self.content:
            lines = self.content.split('\n')
            for i, line in enumerate(lines):
                if i < self.height - 2:  # Account for borders
                    self._draw_text(
                        surface, 
                        font, 
                        self.x + 2, 
                        self.y + 1 + i, 
                        line
                    )
```

### UI Component Event Bridge

```python
# Component-Event Bridge (in component_event_bridge.py)
class ComponentEventBridge:
    """Bridge between the component registry and event system."""
    
    @staticmethod
    def register_component_events(component_id: str, event_types: List[str]) -> None:
        """Register event subscriptions for a component."""
        registry = ComponentRegistry.get_instance()
        event_bus = get_event_bus("ui")
        
        # Register events in registry
        registry.subscriptions[component_id] = set(event_types)
        
        # Create handler to dispatch events to component
        def event_handler(event: Dict[str, Any]) -> None:
            component_ref = registry.components.get(component_id)
            if component_ref is not None:
                component = component_ref()
                if component is not None:
                    component.handle_event(event)
        
        # Subscribe handler to each event type
        for event_type in event_types:
            event_bus.subscribe(event_type, event_handler)
```

## TYPE SAFETY PATTERNS (#type_system)

### Type Guards

```python
def is_resource_event(event: Dict[str, Any]) -> bool:
    """Type guard for resource events."""
    return event["type"].startswith("RESOURCE_") and "resource_id" in event["data"]

def is_module_event(event: Dict[str, Any]) -> bool:
    """Type guard for module events."""
    return event["type"].startswith("MODULE_") and "module_id" in event["data"]

def is_ui_event(event: Dict[str, Any]) -> bool:
    """Type guard for UI events."""
    return event["type"].startswith("UI_") and "component_id" in event["data"]
```

## MANAGER IMPLEMENTATION (#manager_system)

### Manager Base Pattern

```python
class BaseManager:
    """Base class for all manager implementations."""
    
    def __init__(self) -> None:
        """Initialize the manager."""
        # System state
        self.active = True
        self.paused = False
        self.initialized = False
        
        # Update tracking
        self.last_update_time = 0.0
        self.update_interval = 1.0  # seconds
        
        logging.info(f"{self.__class__.__name__} initialized")
        
    def initialize(self) -> bool:
        """Initialize the manager."""
        if self.initialized:
            return True
            
        try:
            self._initialize_internal()
            self.initialized = True
            return True
        except Exception as e:
            logging.error(f"Error initializing {self.__class__.__name__}: {e}")
            return False
            
    def _initialize_internal(self) -> None:
        """Internal initialization implementation."""
        pass
        
    def update(self, dt: float) -> None:
        """Update manager state."""
        if not self.active or self.paused or not self.initialized:
            return
            
        if not self._should_update(dt):
            return
            
        try:
            self._update_internal(dt)
            self.last_update_time = time.time()
        except Exception as e:
            logging.error(f"Error updating {self.__class__.__name__}: {e}")
            
    def _should_update(self, dt: float) -> bool:
        """Check if the manager should update based on time interval."""
        return time.time() - self.last_update_time >= self.update_interval
        
    def _update_internal(self, dt: float) -> None:
        """Internal update implementation."""
        pass
        
    def pause(self) -> bool:
        """Pause the manager."""
        if self.paused:
            return True
            
        self.paused = True
        return True
        
    def resume(self) -> bool:
        """Resume the manager."""
        if not self.paused:
            return True
            
        self.paused = False
        return True
        
    def shutdown(self) -> bool:
        """Shutdown the manager."""
        if not self.active:
            return True
            
        try:
            self._shutdown_internal()
            self.active = False
            return True
        except Exception as e:
            logging.error(f"Error shutting down {self.__class__.__name__}: {e}")
            return False
            
    def _shutdown_internal(self) -> None:
        """Internal shutdown implementation."""
        pass
```

### Concrete Manager Examples

```python
class ResourceManager(BaseManager):
    """Central manager for handling all resource-related operations."""
    
    def __init__(self) -> None:
        """Initialize the resource manager."""
        super().__init__()
        # Resource tracking
        self.resources: Dict[str, Dict[ResourceType, float]] = {}
        self.capacities: Dict[str, Dict[ResourceType, float]] = {}
        self.states: Dict[str, Dict[ResourceType, ResourceState]] = {}
        
        # Flow management
        self.flows: List[ResourceFlow] = []
        self.flow_history: Dict[str, List[Tuple[float, float]]] = {}
        
    def _update_internal(self, dt: float) -> None:
        """Update resource states and flows."""
        self._process_active_flows()
        self._update_resource_states()


class ModuleManager(BaseManager):
    """Central manager for handling all module-related operations."""
    
    def __init__(self) -> None:
        """Initialize the module manager."""
        super().__init__()
        # Module tracking
        self.modules: Dict[str, ModuleInterface] = {}
        self.states: Dict[str, ModuleState] = {}
        self.configs: Dict[str, ModuleConfig] = {}
        
        # Event handlers
        self.on_module_state_change: Dict[str, List[Callable]] = {}
        
    def _update_internal(self, dt: float) -> None:
        """Update all active modules."""
        for module_id, module in self.modules.items():
            if self.states.get(module_id) == ModuleState.ACTIVE:
                try:
                    module.update(dt)
                except Exception as e:
                    self._handle_module_error(module_id, e)
```

## CONTEXT PROVIDER PATTERN (#context_system)

### Context Pattern Overview

```python
class GameContext:
    """Central context for managing game state and coordinating between systems."""
    
    def __init__(self) -> None:
        """Initialize the game context."""
        # State management
        self.state = GameState.INITIALIZING
        self.previous_state = None
        self.state_history: List[Tuple[GameState, float]] = []
        
        # Event system
        self.event_queue: List[GameEvent] = []
        self.event_handlers: Dict[GameEventType, List[Callable[[GameEvent], None]]] = {
            event_type: [] for event_type in GameEventType
        }
        
        # System state
        self.active = True
        self.error_count = 0
        self.last_update = 0.0
        self.update_interval = 1.0  # seconds
        
    def register_event_handler(
        self, event_type: GameEventType, handler: Callable[[GameEvent], None]
    ) -> bool:
        """Register a handler for a specific event type."""
        if event_type not in self.event_handlers:
            return False
            
        self.event_handlers[event_type].append(handler)
        return True
        
    def dispatch_event(self, event: GameEvent) -> None:
        """Dispatch an event to registered handlers."""
        if event.type not in self.event_handlers:
            return
            
        # Add to queue for processing
        self.event_queue.append(event)
        self._process_events()
        
    def update(self, dt: float) -> None:
        """Update game context state."""
        if not self.active:
            return
            
        self.last_update += dt
        if self.last_update < self.update_interval:
            return
            
        try:
            self._process_events()
            self._update_resource_states()
            self._update_module_states()
            
            self.last_update = 0
            self.error_count = 0
        except Exception as e:
            self.error_count += 1
            
            if self.error_count >= 3:
                self.transition_state(GameState.ERROR)
```

### State Transitions and Validation

```python
def transition_state(self, new_state: GameState) -> bool:
    """Transition to a new game state."""
    if not self._is_valid_transition(self.state, new_state):
        logging.warning(
            f"Invalid state transition: {self.state} -> {new_state}"
        )
        return False
        
    try:
        self._update_state_and_notify(new_state)
        return True
    except Exception as e:
        logging.error(f"Error during state transition: {e}")
        return False
        
 def _update_state_and_notify(self, new_state: GameState) -> None:
    """Update the game state and notify observers about the change."""
    self.previous_state = self.state
    self.state = new_state
    self.state_history.append((new_state, time.time()))
    
    # Dispatch state change event
    self.dispatch_event(
        GameEvent(
            type=GameEventType.STATE_CHANGED,
            source="game_context",
            data={
                "old_state": self.previous_state,
                "new_state": self.state,
            },
            timestamp=time.time(),
        )
    )
    
def _is_valid_transition(self, current_state: GameState, new_state: GameState) -> bool:
    """Check if a state transition is valid."""
    # Define valid transitions
    valid_transitions = {
        GameState.INITIALIZING: {GameState.RUNNING, GameState.ERROR},
        GameState.RUNNING: {GameState.PAUSED, GameState.SAVING, GameState.ERROR, GameState.SHUTTING_DOWN},
        GameState.PAUSED: {GameState.RUNNING, GameState.SAVING, GameState.ERROR, GameState.SHUTTING_DOWN},
        GameState.SAVING: {GameState.RUNNING, GameState.PAUSED, GameState.ERROR},
        GameState.LOADING: {GameState.RUNNING, GameState.ERROR},
        GameState.ERROR: {GameState.SHUTTING_DOWN, GameState.INITIALIZING},
        GameState.SHUTTING_DOWN: set(),  # No valid transitions from SHUTTING_DOWN
    }
    
    return new_state in valid_transitions.get(current_state, set())
```

### Specialized Context Implementations

```python
class ModuleContext:
    """Context for managing module lifecycle and dependencies."""
    
    def __init__(self, game_context: GameContext) -> None:
        """Initialize the module context."""
        self.game_context = game_context
        self.modules: Dict[str, Module] = {}
        self.module_states: Dict[str, ModuleState] = {}
        self.dependencies: Dict[str, Set[str]] = {}
        self.listeners: Dict[str, List[Callable[[str, ModuleState], None]]] = {}
        
        # Register for game events
        game_context.register_event_handler(
            GameEventType.MODULE_CHANGED, self._handle_module_changed
        )
        
    def register_module(self, module_id: str, module: Module, dependencies: Optional[Set[str]] = None) -> bool:
        """Register a module with the context."""
        if module_id in self.modules:
            return False
            
        self.modules[module_id] = module
        self.module_states[module_id] = ModuleState.INACTIVE
        self.dependencies[module_id] = dependencies or set()
        self.listeners[module_id] = []
        
        return True
        
    def activate_module(self, module_id: str) -> bool:
        """Attempt to activate a module."""
        if module_id not in self.modules:
            return False
            
        # Check dependencies
        for dep_id in self.dependencies.get(module_id, set()):
            if dep_id not in self.modules or self.module_states.get(dep_id) != ModuleState.ACTIVE:
                return False
                
        # Activate the module
        try:
            self.modules[module_id].activate()
            self._update_module_state(module_id, ModuleState.ACTIVE)
            return True
        except Exception as e:
            self._update_module_state(module_id, ModuleState.ERROR)
            return False
            
    def _update_module_state(self, module_id: str, state: ModuleState) -> None:
        """Update a module's state and notify listeners."""
        if module_id not in self.module_states:
            return
            
        old_state = self.module_states[module_id]
        self.module_states[module_id] = state
        
        # Notify listeners
        for listener in self.listeners.get(module_id, []):
            listener(module_id, state)
            
        # Dispatch game event
        self.game_context.dispatch_event(
            GameEvent(
                type=GameEventType.MODULE_CHANGED,
                source="module_context",
                data={
                    "module_id": module_id,
                    "old_state": old_state,
                    "new_state": state,
                },
                timestamp=time.time(),
            )
        )
```

## ENTITY SYSTEM (#entity_system)

### Core Entity Model

```python
class BaseEntity:
    """Base class for all entities in the game."""
    
    def __init__(
        self,
        entity_id: Optional[str] = None,
        entity_type: str = "generic",
        color: Tuple[int, int, int] = (255, 255, 255),
        position: Optional[Tuple[int, int]] = None,
    ) -> None:
        """Initialize a base entity."""
        # Core entity attributes
        self.entity_id = entity_id or str(uuid.uuid4())
        self.entity_type = entity_type
        self.color = color
        self.position = position
        self.active = True
        self.created_at = 0  # Game tick when entity was created

        # Stats and properties
        self.health = 100
        self.max_health = 100
        self.level = 1
        self.tags = set()  # Set of tags for entity categorization
        
    def update(self, game_state: Dict[str, Any]) -> None:
        """Update the entity state based on the current game state."""
        # Base implementation does nothing
        pass
        
    def is_active(self) -> bool:
        """Check if the entity is active."""
        return self.active
        
    def deactivate(self) -> None:
        """Deactivate the entity."""
        self.active = False
        
    def activate(self) -> None:
        """Activate the entity."""
        self.active = True
        
    def set_position(self, x: int, y: int) -> None:
        """Set the entity's position."""
        self.position = (x, y)
        
    def add_tag(self, tag: str) -> None:
        """Add a tag to the entity."""
        self.tags.add(tag)
        
    def has_tag(self, tag: str) -> bool:
        """Check if the entity has a specific tag."""
        return tag in self.tags
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert the entity to a dictionary for serialization."""
        return {
            "entity_id": self.entity_id,
            "entity_type": self.entity_type,
            "position": self.position,
            "active": self.active,
            "health": self.health,
            "level": self.level,
            "tags": list(self.tags),
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BaseEntity":
        """Create an entity from a dictionary."""
        entity = cls(
            entity_id=data.get("entity_id"),
            entity_type=data.get("entity_type", "generic"),
            position=data.get("position"),
        )
        return entity
```

### Entity Lifecycle

```python
# Entity creation pattern
def create_entity(entity_type: str, **kwargs) -> BaseEntity:
    """Factory function for creating entities."""
    entity_mapping = {
        "player": Player,
        "miner": MinerEntity,
        "crew": CrewMember,
        "enemy": EnemyShip,
    }
    
    if entity_type not in entity_mapping:
        logging.error(f"Unknown entity type: {entity_type}")
        return None
        
    try:
        entity_class = entity_mapping[entity_type]
        return entity_class(**kwargs)
    except Exception as e:
        logging.error(f"Error creating entity of type {entity_type}: {e}")
        return None

# Entity update pattern in the game loop
def update_entities(entities: List[BaseEntity], game_state: Dict[str, Any]) -> None:
    """Update all active entities."""
    for entity in entities:
        if entity.is_active():
            try:
                entity.update(game_state)
            except Exception as e:
                logging.error(f"Error updating entity {entity.entity_id}: {e}")
                entity.deactivate()

# Entity cleanup pattern
def cleanup_entities(entities: List[BaseEntity]) -> List[BaseEntity]:
    """Remove inactive entities from the list."""
    return [entity for entity in entities if entity.is_active()]
```

### Entity Tagging System

```python
# Entity tagging pattern
def tag_entities(entities: List[BaseEntity], tag: str, condition_func) -> int:
    """Tag entities that match a condition."""
    count = 0
    for entity in entities:
        if condition_func(entity):
            entity.add_tag(tag)
            count += 1
    return count

# Entity filtering by tag pattern
def get_entities_by_tag(entities: List[BaseEntity], tag: str) -> List[BaseEntity]:
    """Get all entities with a specific tag."""
    return [entity for entity in entities if entity.has_tag(tag)]
```

### Entity Relationship Patterns

```python
class Fleet(BaseEntity):
    """A fleet entity that manages child entities."""
    
    def __init__(self, fleet_id: Optional[str] = None, name: str = "Fleet") -> None:
        """Initialize a fleet."""
        super().__init__(entity_id=fleet_id, entity_type="fleet")
        self.name = name
        self.members: List[BaseEntity] = []
        self.capacity = 10
        
    def add_member(self, entity: BaseEntity) -> bool:
        """Add an entity to the fleet."""
        if len(self.members) >= self.capacity:
            return False
            
        self.members.append(entity)
        return True
        
    def remove_member(self, entity_id: str) -> Optional[BaseEntity]:
        """Remove an entity from the fleet."""
        for i, entity in enumerate(self.members):
            if entity.entity_id == entity_id:
                return self.members.pop(i)
        return None
        
    def update(self, game_state: Dict[str, Any]) -> None:
        """Update the fleet and all its members."""
        super().update(game_state)
        
        # Update all active fleet members
        for member in self.members:
            if member.is_active():
                member.update(game_state)
                
        # Clean up inactive members
        self.members = [m for m in self.members if m.is_active()]
```

## TESTING SYSTEM (#testing_system)

Space Muck implements a comprehensive testing framework with distinct categories of tests, each designed to validate different aspects of the system. Testing patterns follow a consistent structure, utilizing Python's unittest framework with specialized test cases for verification, benchmarking, and performance testing.

### Core Test Categories

1. **Unit Tests** - Validate individual components and methods
2. **Verification Tests** - Confirm expected behavior of complex systems
3. **Benchmarks** - Measure and track performance metrics
4. **Integration Tests** - Test interaction between multiple components
5. **Performance Tests** - Ensure system maintains performance under load

### Test Implementation Pattern

```python
class TestBaseEntity(unittest.TestCase):
    """Test cases for the BaseEntity class."""

    def setUp(self):
        """Set up test fixtures."""
        # Create a basic entity for testing
        self.entity = BaseEntity(
            entity_id="test-123",
            entity_type="test_entity",
            color=(255, 0, 0),
            position=(10, 20),
        )

    def test_initialization(self):
        """Test that entity initializes with correct values."""
        self.assertEqual(self.entity.entity_id, "test-123")
        self.assertEqual(self.entity.entity_type, "test_entity")
        self.assertTrue(self.entity.active)
}
```

### Benchmark Testing Pattern

```python
def time_function(func: Callable, *args, **kwargs) -> float:
    """Measure the execution time of a function."""
    start_time = time.time()
    func(*args, **kwargs)
    end_time = time.time()
    return end_time - start_time


def benchmark_cellular_automaton(
    generator: BaseGenerator, grid_sizes: List[int], iterations: int = 3
) -> Dict[str, List[float]]:
    """Benchmark the apply_cellular_automaton method."""
    results = {"grid_sizes": grid_sizes, "times": []}

    for size in grid_sizes:
        # Create a random grid
        grid = rng.choice([0, 1], size=(size, size), p=[0.7, 0.3])

        # Time the cellular automaton operation
        execution_time = time_function(
            generator.apply_cellular_automaton,
            grid=grid,
            birth_set={3},
            survival_set={2, 3},
            iterations=iterations,
            wrap=True,
        )

        results["times"].append(execution_time)
```

### Performance Testing Pattern

```python
class TestAsteroidFieldPerformance(unittest.TestCase):
    """Test performance of the AsteroidField class."""

    def setUp(self):
        """Set up test environment."""
        # Create a large field for performance testing
        self.field = AsteroidField(width=400, height=300)

    def test_update_performance(self):
        """Test performance of the update method."""
        # Time the update method
        start_time = time.time()
        self.field.update()
        end_time = time.time()

        # Update should complete in reasonable time
        self.assertLess(end_time - start_time, 0.5, "Update took too long")
```

### Verification Test Pattern

```python
class TestVerificationEquivalence(unittest.TestCase):
    """Test cases that were originally in verify_base_entity.py."""

    def test_verification_basic_functionality(self):
        """Test the basic functionality originally in verify_base_entity."""
        entity = BaseEntity(entity_id="test-verify", entity_type="test_verification")
```

### Test Organization and Structure

```python
# Standard test class structure with setUp method and test case methods
class TestBaseEntity(unittest.TestCase):
    """Test cases for the BaseEntity class."""

    def setUp(self):
        """Set up test fixtures."""
        # Create a basic entity for testing
        self.entity = BaseEntity(
            entity_id="test-123",
            entity_type="test_entity",
            color=(255, 0, 0),
            position=(10, 20),
        )

    def test_initialization(self):
        """Test that entity initializes with correct values."""
        # Test with explicit values
        self.assertEqual(self.entity.entity_id, "test-123")
        self.assertEqual(self.entity.entity_type, "test_entity")
        self.assertEqual(self.entity.color, (255, 0, 0))
        self.assertEqual(self.entity.position, (10, 20))
        self.assertTrue(self.entity.active)
        self.assertEqual(self.entity.health, 100)
        self.assertEqual(self.entity.max_health, 100)
        self.assertEqual(self.entity.level, 1)
        self.assertEqual(self.entity.tags, set())

        # Test with default values
        default_entity = BaseEntity()
        self.assertIsNotNone(default_entity.entity_id)  # Should generate UUID
        self.assertEqual(default_entity.entity_type, "unknown")
```

### Mock Data Generation Patterns

```python
from tests.tools.mock_data_test import (
    create_mock_field_data,
    create_mock_race,
    create_mock_shop_upgrade,
    _create_asteroid_clusters,
    _create_rare_grid,
    _create_energy_grid,
    _create_entity_grid,
    _add_circular_cluster,
)

def create_mock_field_data(width=100, height=80, complexity=0.5):
    """Create mock field data for testing."""
    # Generate the asteroid grid with clusters
    grid = _create_asteroid_clusters(width, height)
    
    # Generate the rare minerals grid
    rare_grid, rare_positions = _create_rare_grid(width, height)
    
    # Generate the energy grid
    energy_grid, energy_positions = _create_energy_grid(width, height)
    
    # Generate the entity grid
    entity_grid, entities = _create_entity_grid(width, height)
    
    return {
        "grid": grid,
        "rare_grid": rare_grid,
        "rare_positions": rare_positions,
        "energy_grid": energy_grid,
        "energy_positions": energy_positions,
        "entity_grid": entity_grid,
        "entities": entities,
        "complexity": complexity,
    }
```

### Test Verification Patterns

```python
def test_inheritance_hierarchy(self):
    """Test the inheritance hierarchy using real implementations."""
    # Create instances of each class in the hierarchy
    base_entity = BaseEntity()
    miner_entity = MinerEntity()
    player_entity = PlayerEntity()
    
    # Verify inheritance relationships
    self.assertIsInstance(base_entity, BaseEntity)
    self.assertIsInstance(miner_entity, BaseEntity)
    self.assertIsInstance(player_entity, BaseEntity)
    self.assertIsInstance(player_entity, MinerEntity)
    
    # Verify each level adds its specific attributes
    self.assertTrue(hasattr(base_entity, "entity_id"))
    self.assertTrue(hasattr(base_entity, "entity_type"))
    
    self.assertTrue(hasattr(miner_entity, "race_id"))
    self.assertEqual(miner_entity.trait, "standard")
        
        # Verify entity initialization
        self.assertEqual(entity.entity_id, "test-verify")
        self.assertEqual(entity.entity_type, "test_verification")
        self.assertTrue(entity.active)
        
        # Verify tag functionality
        entity.add_tag("important")
        self.assertTrue(entity.has_tag("important"))
```
-->

## TESTING FRAMEWORK (#testing_system)
<!-- 
Analyze testing patterns used in the codebase.
Extract testing factory patterns, testing utilities, and common test structures.
Include code examples showing test implementation.
Focus on patterns, not explanations.
Example:
```typescript
const testModuleEvents = createTestModuleEvents();
const events = testModuleEvents.getEmittedEvents('TEST_EVENT');
```
-->

## PERFORMANCE OPTIMIZATION (#performance_system)

The Space Muck codebase implements several performance optimization strategies focused on monitoring, measurement, and optimized algorithms for computationally intensive tasks. These patterns enable the game to maintain consistent performance even with complex procedural generation and large numbers of entities.

### Performance Measurement Pattern

```python
def log_performance_start(operation_name: str) -> float:
    """Mark the start of a performance-sensitive operation.
    
    Args:
        operation_name: Identifier for the operation being monitored
        
    Returns:
        float: Start timestamp for the operation
    """
    return time.time()


def log_performance_end(operation_name: str, start_time: float) -> float:
    """Log the completion of a performance-sensitive operation.
    
    Args:
        operation_name: Identifier for the operation being monitored
        start_time: Start timestamp from log_performance_start
        
    Returns:
        float: Duration of the operation in seconds
    """
    duration = time.time() - start_time
    logging.debug(f"{operation_name} completed in {duration:.4f} seconds")
    return duration
```

### Game Loop Performance Tracking

```python
class GameLoop:
    """Main game loop with performance monitoring."""
    
    def __init__(self, target_fps: int = 60):

### GPU Acceleration Framework

```python
# Core GPU detection and management
def is_gpu_available() -> bool:
    """Check if any GPU acceleration is available."""
    return CUDA_AVAILABLE or CUPY_AVAILABLE or MPS_AVAILABLE or METALGPU_AVAILABLE


def get_available_backends() -> List[str]:
    """Get a list of available GPU backends."""
    backends = []
    if CUDA_AVAILABLE:
        backends.append("cuda")
    if CUPY_AVAILABLE:
        backends.append("cupy")
    if NUMBA_AVAILABLE:
        backends.append("numba")
    if MPS_AVAILABLE:
        backends.append("mps")
    if METALGPU_AVAILABLE:
        backends.append("metalgpu")
    if not backends:
        backends.append("cpu")
    return backends


def to_gpu(array: np.ndarray) -> Union[np.ndarray, Any]:
    """Transfer a numpy array to the GPU if available."""
    # Try CuPy first (NVIDIA/AMD GPUs)
    if CUPY_AVAILABLE:
        return cp.asarray(array)

    # Try PyTorch MPS for macOS
    if MPS_AVAILABLE and TORCH_AVAILABLE:
        try:
            return torch.from_numpy(array).to(device=mps_device)
        except Exception as e:
            logging.warning(f"Failed to transfer array to MPS: {e}")

    # If no GPU transfer was successful, return the original array
    return array
```

### Game Loop Performance Tracking

```python
class GameLoop:
    """Main game loop with performance monitoring."""
    
    def __init__(self, target_fps: int = 60):
        # Performance tracking
        self.frame_times: List[float] = []
        self.frame_count: int = 0
        self.fps: float = 0.0
        self.performance_metrics: Dict[str, float] = {}
        
    def _update_systems(self, delta_time: float) -> None:
        """Update all game systems with performance tracking."""
        for update_func in self.update_functions:
            try:
                log_performance_start(f"update_{update_func.__name__}")
                update_func(delta_time)
                log_performance_end(f"update_{update_func.__name__}")
            except Exception as e:
                logging.error(f"Error in {update_func.__name__}: {e}")
                
    def _monitor_performance(self, delta_time: float) -> None:
        """Monitor and log performance metrics."""
        # Calculate frame rate
        self.frame_times.append(delta_time)
        if len(self.frame_times) > 100:
            self.frame_times.pop(0)
        self.fps = 1.0 / (sum(self.frame_times) / len(self.frame_times))
```

### Optimized Algorithm Implementations

```python
def apply_cellular_automaton_optimized(grid: np.ndarray, birth_set: Set[int], 
                                      survival_set: Set[int], iterations: int = 1,
                                      wrap: bool = False) -> np.ndarray:
    """Optimized version of cellular automaton algorithm using numpy vectorization."""
    height, width = grid.shape
    new_grid = grid.copy()
    
    # Pre-compute indices for better performance
    for _ in range(iterations):
        # Count neighbors using vectorized operations
        neighbors = np.zeros_like(grid)
        for dy in [-1, 0, 1]:
            for dx in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                if wrap:
                    shifted = np.roll(np.roll(grid, dy, axis=0), dx, axis=1)
                else:
                    # Implementation for non-wrapping grid
                    pass
                neighbors += shifted
                
        # Apply rules with vectorized operations
        birth = np.isin(neighbors, list(birth_set)) & (grid == 0)
        survive = np.isin(neighbors, list(survival_set)) & (grid == 1)
        new_grid = np.zeros_like(grid)
        new_grid[birth | survive] = 1
        grid = new_grid
        
    return grid
```

### Batch Processing Pattern

```python
class BatchEventProcessor:
    """Batches events and dispatches them efficiently to multiple event buses."""
    
    def __init__(self, batch_size: int = 100):
        self.event_queue: List[GameEvent] = []
        self.batch_size = batch_size
        self.event_buses: List[EventBus] = []
        
    def add_event(self, event: GameEvent) -> None:
        """Add event to the batch queue."""
        self.event_queue.append(event)
        
        # Process batch if queue is full
        if len(self.event_queue) >= self.batch_size:
            self.process_batch()
            
    def process_batch(self) -> None:
        """Process all events in the current batch."""
        if not self.event_queue:
            return
            
        # Group events by type for efficient processing
        event_groups: Dict[str, List[GameEvent]] = {}
        for event in self.event_queue:
            event_type = event.event_type
            if event_type not in event_groups:
                event_groups[event_type] = []
            event_groups[event_type].append(event)
            
        # Process each group
        for event_type, events in event_groups.items():
            for bus in self.event_buses:
                bus.process_events(event_type, events)
                
        # Clear the queue
        self.event_queue.clear()
```

## COMMON ERRORS AND FIXES (#error_fixes)

This section documents common error patterns encountered in the Space Muck codebase and their standard solutions, categorized by system type. These patterns provide guidance for addressing similar issues in future development.

### Type System Errors

```python
# Error: Incompatible type assignment between entity subtypes
# Fix: Use proper type guards before operations

def process_entity(entity: BaseEntity) -> None:
    # Error-prone approach
    if entity.entity_type == "miner":
        # TypeError: BaseEntity has no attribute 'mine_resources'
        entity.mine_resources()  # Error: BaseEntity doesn't have this method
    
    # Correct approach with type checking
    if entity.entity_type == "miner" and isinstance(entity, MinerEntity):
        entity.mine_resources()  # Safe: Type is verified
        
    # Alternative with type annotations and casting
    if entity.entity_type == "miner":
        miner = cast(MinerEntity, entity)  # Explicit cast with type hint
        miner.mine_resources()
```

### Resource Management Errors

```python
# Error: Resource leaks or missing cleanup
# Fix: Use context managers and explicit resource release

# Error-prone approach
def process_large_dataset(filename: str) -> Dict[str, Any]:
    data = load_large_dataset(filename)  # Loads data into memory
    result = calculate_statistics(data)
    # Missing cleanup, data stays in memory
    return result

# Correct approach with proper resource management
def process_large_dataset_fixed(filename: str) -> Dict[str, Any]:
    try:
        data = load_large_dataset(filename)
        result = calculate_statistics(data)
        return result
    finally:
        # Explicit cleanup
        if 'data' in locals():
            del data  # Release memory
```

### Concurrency Errors

```python
# Error: Race conditions in entity updates
# Fix: Use atomic operations and proper synchronization

# Error-prone approach with race condition
def update_entities(entities: List[BaseEntity]) -> None:
    for entity in entities:
        # Race condition if called from multiple threads
        entity.resources += calculate_resource_gain(entity)

# Correct approach with atomic updates
def update_entities_fixed(entities: List[BaseEntity]) -> None:
    # Process all calculations first
    updates = [(entity, calculate_resource_gain(entity)) for entity in entities]
    
    # Apply updates atomically
    with lock:  # Assume thread lock is defined
        for entity, gain in updates:
            entity.resources += gain
```

### Event System Errors

```python
# Error: Events not being properly unsubscribed
# Fix: Track subscriptions and ensure cleanup

# Error-prone approach
class GameSystem:
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        # Subscribe but no cleanup mechanism
        self.event_bus.subscribe("PLAYER_MOVE", self.on_player_move)
    
    def on_player_move(self, event: GameEvent) -> None:
        # Handle event
        pass

# Correct approach with proper subscription management
class GameSystemFixed:
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.subscriptions = []  # Track subscriptions
        # Store subscription for later cleanup
        self.subscriptions.append(
            self.event_bus.subscribe("PLAYER_MOVE", self.on_player_move)
        )
    
    def cleanup(self) -> None:
        # Unsubscribe all handlers
        for subscription in self.subscriptions:
            self.event_bus.unsubscribe(subscription)
        self.subscriptions.clear()
```

### Performance Bottlenecks

```python
# Error: Inefficient entity filtering operation
# Fix: Use optimized filtering methods

# Slow approach
def find_entities_by_tags(entities: List[BaseEntity], tags: Set[str]) -> List[BaseEntity]:
    result = []
    for entity in entities:
        matches_all = True
        for tag in tags:
            if not entity.has_tag(tag):
                matches_all = False
                break
        if matches_all:
            result.append(entity)
    return result

# Optimized approach
def find_entities_by_tags_optimized(entities: List[BaseEntity], tags: Set[str]) -> List[BaseEntity]:
    # Use set operations for efficiency
    return [entity for entity in entities if tags.issubset(entity.tags)]
```

## PROCEDURAL GENERATION SYSTEM (#procedural_system)

The Space Muck codebase implements a sophisticated procedural generation system for creating game environments, asteroid fields, and other dynamic content. The system uses a layered approach, combining multiple algorithms to create complex, varied, and realistic procedural content.

### Core Generation Architecture

```python
class BaseGenerator:
    """Base class for all procedural generators in the game."""
    
    def __init__(self, entity_id: Optional[str] = None, entity_type: str = "generator",
                 seed: Optional[int] = None, width: int = 100, height: int = 100,
                 color: Tuple[int, int, int] = (255, 255, 255),
                 position: Optional[Tuple[int, int]] = None,
                 noise_generator: Optional[NoiseGenerator] = None) -> None:
        """Initialize the base generator with common parameters."""
        super().__init__(entity_id=entity_id, entity_type=entity_type)
        
        # Core parameters
        self.seed = seed if seed is not None else np.random.randint(0, 2**32 - 1)
        self.width = width
        self.height = height
        self.color = color
        self.set_position(position[0], position[1]) if position else None
        
        # RNG initialization with seed for reproducibility
        self.rng = np.random.RandomState(self.seed)
        
        # Parameter dictionary for algorithm configuration
        self.parameters: Dict[str, Any] = {}
        
        # Dependency injection for noise generator
        self.noise_generator = noise_generator or NoiseGenerator(self.seed)
```

### Specialized Generator Implementation

```python
@inject
class ProceduralGenerator(BaseGenerator):
    """Handles procedural generation for asteroid fields using multiple algorithms."""

    def __init__(self, entity_id: Optional[str] = None, seed: Optional[int] = None,
                 width: int = 100, height: int = 100,
                 color: Tuple[int, int, int] = (100, 200, 100),
                 position: Optional[Tuple[int, int]] = None,
                 noise_generator: Optional[NoiseGenerator] = None) -> None:
        """Initialize the procedural generator with an optional seed."""
        super().__init__(entity_id=entity_id, entity_type="procedural", seed=seed,
                        width=width, height=height, color=color, position=position,
                        noise_generator=noise_generator)

        # Statistical parameters
        self.value_distribution = stats.lognorm(s=0.6, scale=50)

        # Configure cellular automaton parameters
        self.set_parameter("birth_set", {3})
        self.set_parameter("survival_set", {2, 3})
        self.set_parameter("iterations", 3)
        self.set_parameter("wrap", True)

        # Fractal parameters
        self.set_parameter("fractal_depth", 3)
```

### Multi-Algorithm Generation Pattern

```python
def generate_asteroid_field(self, noise_type: str = "perlin") -> Tuple[np.ndarray, Dict]:
    """Generate an asteroid field using specified noise type and cellular automaton."""
    # Track performance
    start = log_performance_start("generate_asteroid_field")
    
    try:
        # Step 1: Generate base noise map
        noise_grid = self.noise_generator.generate(
            width=self.width,
            height=self.height,
            noise_type=noise_type,
            scale=self.get_parameter("noise_scale", 10.0),
        )
        
        # Step 2: Threshold the noise to create binary asteroid map
        threshold = self.get_parameter("threshold", 0.5)
        binary_grid = (noise_grid > threshold).astype(np.int8)
        
        # Step 3: Apply cellular automaton rules for natural-looking shapes
        evolved_grid = self.apply_cellular_automaton(
            grid=binary_grid,
            birth_set=self.get_parameter("birth_set", {3}),
            survival_set=self.get_parameter("survival_set", {2, 3}),
            iterations=self.get_parameter("iterations", 3),
            wrap=self.get_parameter("wrap", True),
        )
        
        # Step 4: Generate metadata about the field
        metadata = {
            "seed": self.seed,
            "asteroid_count": np.sum(evolved_grid),
            "density": np.sum(evolved_grid) / (self.width * self.height),
            "generation_time": time.time() - start,
        }
        
        return evolved_grid, metadata
    
    finally:
        log_performance_end("generate_asteroid_field", start)
```

### Layered Generation Approach

```python
def generate_multi_layer_asteroid_field(self) -> Tuple[np.ndarray, Dict]:
    """Generate a complex asteroid field with multiple layers of different algorithms."""
    start_time = log_performance_start("generate_multi_layer_asteroid_field")
    
    # Base layer using Perlin noise
    base_grid, base_metadata = self.generate_asteroid_field(noise_type="perlin")
    
    # Detail layer using Simplex noise (smaller features)
    self.set_parameter("noise_scale", 5.0)  # Higher frequency for details
    detail_grid, _ = self.generate_asteroid_field(noise_type="simplex")
    
    # Feature layer using Worley noise (creates cellular/cluster patterns)
    self.set_parameter("noise_scale", 15.0)
    feature_grid, _ = self.generate_asteroid_field(noise_type="worley")
    
    # Combine layers with different weights for final result
    combined_grid = (
        base_grid * 0.5 +
        detail_grid * 0.3 +
        feature_grid * 0.2
    ) > 0.4  # Threshold for final binary grid
    
    # Apply cellular automaton to clean up the result
    final_grid = self.apply_cellular_automaton(
        grid=combined_grid.astype(np.int8),
        birth_set=self.get_parameter("birth_set", {3}),
        survival_set=self.get_parameter("survival_set", {2, 3}),
        iterations=2,  # Fewer iterations to preserve details
        wrap=True,
    )
    
    # Generate enhanced metadata
    metadata = {
        **base_metadata,  # Include base layer metadata
        "layers": 3,
        "algorithm": "multi_layer",
        "asteroid_count": np.sum(final_grid),
        "density": np.sum(final_grid) / (self.width * self.height),
    }
    
    log_performance_end("generate_multi_layer_asteroid_field", start_time)
    return final_grid.astype(np.int8), metadata
```

## EXPLORATION SYSTEM (#exploration_system)

The exploration system in Space Muck manages the procedural discovery of space regions, resource scanning, and mission-based exploration. It integrates with the procedural generation system to create explorable regions with varied content.

### Core Exploration States and Types

```python
# Exploration States define the current status of a region
class ExplorationState(Enum):
    UNEXPLORED = auto()  # Region has been identified but not explored
    SCANNING = auto()    # Active exploration is in progress
    EXPLORED = auto()    # Exploration complete with normal outcome
    DEPLETED = auto()    # Exploration complete, no significant discoveries
    DANGEROUS = auto()   # Exploration complete but hazards present


# Region Types categorize the primary characteristics of a space region
class RegionType(Enum):
    EMPTY = auto()        # Mostly empty space
    RESOURCE_RICH = auto() # Contains exploitable resources
    ANOMALY = auto()      # Contains unusual phenomena
    SETTLEMENT = auto()   # Contains NPC settlements
    HAZARD = auto()       # Contains dangerous elements


# Discovery Categories classify found items/phenomena
class DiscoveryType(Enum):
    RESOURCE = auto()     # Minable or harvestable material
    TECHNOLOGY = auto()   # Technological artifact or data
    ARTIFACT = auto()     # Cultural or historical object
    STRUCTURE = auto()    # Built environment or construction
    PHENOMENON = auto()   # Natural or artificial phenomenon
```

### Region Representation

```python
@dataclass
class Region:
    """Represents an explorable region in space."""

    region_id: str
    position: Tuple[int, int]  # Grid coordinates
    size: float                 # Relative size metric
    type: RegionType            # Primary region type
    state: ExplorationState = ExplorationState.UNEXPLORED
    resources: Dict[str, float] = None  # Resource types and quantities
    hazard_level: float = 0.0           # 0.0-1.0 danger rating
    discoveries: List[str] = None       # IDs of discoveries made

    def __post_init__(self):
        """Initialize optional fields."""
        self.resources = self.resources or {}
        self.discoveries = self.discoveries or []
```

### Mission Management

```python
@dataclass
class ExplorationMission:
    """Represents an active exploration mission."""

    mission_id: str
    target_region: str        # ID of region being explored
    pattern: str              # Exploration strategy pattern
    duration: float           # Expected time to complete
    progress: float = 0.0     # 0.0-1.0 completion percentage 
    discoveries: List[str] = None  # IDs of discoveries made
    active: bool = True       # Whether mission is ongoing
    
    def __post_init__(self):
        """Initialize optional fields."""
        self.discoveries = self.discoveries or []
```

### Exploration Manager Implementation

```python
class ExplorationManager:
    """Central manager for handling all exploration-related operations."""

    def __init__(self) -> None:
        """Initialize the exploration manager."""
        # Region tracking
        self.regions: Dict[str, Region] = {}
        self.region_grid: Dict[Tuple[int, int], str] = {}  # Position to region_id mapping

        # Mission management
        self.active_missions: Dict[str, ExplorationMission] = {}
        self.completed_missions: Set[str] = set()

        # Discovery tracking
        self.discoveries: Dict[str, DiscoveryType] = {}
        self.discovery_locations: Dict[str, str] = {}  # Discovery to region_id mapping

        # System state
        self.active = True
        self.paused = False
        self.update_interval = 1.0  # seconds
        self.last_update = 0.0

        # Exploration settings
        self.scan_range = 10.0
        self.discovery_chance = 0.1
        self.hazard_threshold = 0.7
        
    def register_region(
        self,
        position: Tuple[int, int],
        size: float,
        region_type: RegionType = RegionType.EMPTY,
    ) -> Optional[str]:
        """Register a new region for exploration."""
        # Implementation details...
        
    def start_exploration(
        self, region_id: str, pattern: str = "grid", duration: float = 60.0
    ) -> Optional[str]:
        """Start an exploration mission in a region."""
        # Implementation details...
        
    def update(self, dt: float) -> None:
        """Update exploration missions and process discoveries."""
        # Implementation details...
```

### Exploration Integration Pattern

```python
class GameContext:
    def __init__(self):
        # Initialize exploration system
        self.exploration_manager = ExplorationManager()
        
    def update(self, dt: float):
        # Update exploration with proper timing
        self.exploration_manager.update(dt)
        
        # Handle any new discoveries
        for mission_id, mission in self.exploration_manager.active_missions.items():
            if mission.discoveries and not mission.discoveries_processed:
                self.process_new_discoveries(mission)
                mission.discoveries_processed = True
```

### Player Exploration Integration

```python
class Player(BaseEntity):
    # Other player methods...
    
    def _generate_exploration_quest(
        self,
        difficulty: int = 1,
        reward: int = 100,
        target_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Generate an exploration-type quest."""
        # Get unexplored regions in range
        if self.game_context:
            nearby_regions = self.game_context.exploration_manager.get_nearby_regions(
                self.position, self.scan_range
            )
            unexplored = [r for r in nearby_regions 
                        if self.game_context.exploration_manager.get_region_state(r) 
                        == ExplorationState.UNEXPLORED]
            if unexplored and not target_id:
                target_id = random.choice(unexplored)
        
        # Create quest data
        return {
            "id": f"exploration_{self.level}_{random.randint(1000, 9999)}",
            "type": "exploration",
            "title": f"Explore {target_id if target_id else 'unknown region'}",
            "description": f"Conduct exploration mission in region {target_id}.",
            "difficulty": difficulty,
            "reward": reward,
            "target_id": target_id,
            "progress": 0.0,
            "completed": False,
        }
```

## COMBAT SYSTEM (#combat_system)

The combat system manages encounters between the player and enemy ships, handling turn-based space combat with various actions and outcomes.

### Core Combat Flow

```python
class CombatSystem:
    """Manages combat encounters between the player and enemy ships."""

    def __init__(self, player: Player) -> None:
        """Initialize the combat system."""
        self.player = player
        self.current_enemy = None
        self.combat_active = False
        self.turn_count = 0
        self.max_turns = 20  # Maximum turns before combat auto-resolves
        self.combat_log = []

    def start_combat(self, enemy: Optional[EnemyShip] = None) -> Dict[str, Any]:
        """Start a combat encounter with an enemy ship."""
        # Implementation details...
        
    def execute_combat_turn(self) -> Dict[str, Any]:
        """Execute a full combat turn (player and enemy actions)."""
        # Implementation details...
        
    def player_attack(self) -> Dict[str, Any]:
        """Execute a player attack against the current enemy."""
        # Implementation details...
        
    def enemy_attack(self) -> Dict[str, Any]:
        """Execute an enemy attack against the player."""
        # Implementation details...
        
    def player_flee(self) -> Dict[str, Any]:
        """Attempt to flee from combat."""
        # Implementation details...
        
    def end_combat(self, reason: str = "Combat ended") -> Dict[str, Any]:
        """End the current combat encounter."""
        # Implementation details...
```

### Enemy Generation

```python
def generate_enemy(
    self,
    difficulty: str = None,
    level: Optional[int] = None,
    faction: Optional[str] = None,
    position: Optional[Tuple[int, int]] = None,
) -> EnemyShip:
    """Generate an enemy ship for combat."""
    # Determine difficulty if not provided
    if not difficulty:
        difficulties = ["easy", "medium", "hard", "elite"]
        weights = [0.4, 0.3, 0.2, 0.1]  # Higher weights for easier difficulties
        difficulty = random.choices(difficulties, weights=weights, k=1)[0]
    
    # Determine level if not provided
    if level is None:
        if self.player:
            # Base level on player level with some variation
            player_level = getattr(self.player, "level", 1)
            level = max(1, player_level + random.randint(-1, 1))
        else:
            level = random.randint(1, 5)
    
    # Create new enemy with determined stats
    enemy = EnemyShip(
        ship_id=f"enemy_{random.randint(1000, 9999)}",
        name=f"Hostile {difficulty.capitalize()} Ship",
        level=level,
        faction=faction or random.choice(["pirates", "raiders", "mercenaries"]),
        position=position or (random.randint(0, GAME_MAP_SIZE), random.randint(0, GAME_MAP_SIZE)),
    )
    
    # Apply difficulty modifiers
    difficulty_modifiers = {
        "easy": 0.8,
        "medium": 1.0,
        "hard": 1.2,
        "elite": 1.5,
    }
    
    # Apply stat modifiers based on difficulty
    modifier = difficulty_modifiers.get(difficulty, 1.0)
    enemy.max_health = int(enemy.max_health * modifier)
    enemy.health = enemy.max_health
    enemy.attack_power = int(enemy.attack_power * modifier)
    enemy.defense = int(enemy.defense * modifier)
    
    return enemy
```

### Combat Resolution

```python
def _handle_enemy_destroyed(self) -> Dict[str, Any]:
    """Handle enemy ship destruction."""
    reward_base = 10 * self.current_enemy.level
    reward_multiplier = 1 + (self.turn_count / 10)  # Shorter battles give higher rewards
    credits_reward = int(reward_base * reward_multiplier)
    
    # Experience points based on enemy level
    xp_reward = self.current_enemy.level * 5
    
    # Add loot based on enemy type/level
    loot = self._generate_combat_loot()
    
    # Apply rewards to player
    if hasattr(self.player, "add_credits"):
        self.player.add_credits(credits_reward)
    
    if hasattr(self.player, "add_experience"):
        self.player.add_experience(xp_reward)
    
    # Add loot to player inventory
    if loot and hasattr(self.player, "add_to_inventory"):
        for item, quantity in loot.items():
            self.player.add_to_inventory(item, quantity)
    
    result = {
        "success": True,
        "message": f"Enemy destroyed! Earned {credits_reward} credits and {xp_reward} XP.",
        "credits": credits_reward,
        "xp": xp_reward,
        "loot": loot,
        "turns": self.turn_count,
    }
    
    # End combat
    self.end_combat("Enemy destroyed")
    
    return result
```

### Combat UI Integration

```python
def print_combat_header() -> None:
    print(
        """
┌─────────────────── [ SPACE COMBAT SYSTEM ] ────────────────────┐
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐     │
│  │ ATK │ │ DEF │ │ REP │ │ SCN │ │ TAR │ │ ESC │ │ HLP │     │
│  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘     │
│                                                              │"""
    )

def print_combat_success(message: str, details: List[str] = None) -> None:
    print(
        """
│  ┏━━━━━━━━━━━━━━━━━━ COMBAT ACTION ━━━━━━━━━━━━━━━━━━━━┓   │
│  ┃                                                       ┃   │
│  ┃  ✓ {:<52} ┃   │""".format(message)
    )

    if details:
        for detail in details:
            print("│  ┃  • {:<52} ┃   │".format(detail))

    print(
        """
│  ┃                                                       ┃   │
│  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   │
│                                                              │"""
    )
```

### Combat System Integration Pattern

```python
class GameContext:
    def __init__(self):
        # Initialize player
        self.player = Player(player_id="player_1", name="Captain")
        
        # Initialize combat system with player reference
        self.combat_system = CombatSystem(self.player)
        
    def handle_enemy_encounter(self, enemy_type: str = None, difficulty: str = None):
        # Generate or use specific enemy
        if enemy_type:
            # Create specific enemy type
            enemy = self._create_specific_enemy(enemy_type, difficulty)
        else:
            # Generate random enemy based on difficulty
            enemy = self.combat_system.generate_enemy(difficulty=difficulty)
            
        # Start combat with the enemy
        combat_results = self.combat_system.start_combat(enemy)
        
        return combat_results
        
    def process_combat_turn(self, action: str, **kwargs):
        """Process a player combat action."""
        results = None
        
        if not self.combat_system.combat_active:
            return {"success": False, "message": "No active combat session"}
            
        # Handle different combat actions
        if action == "attack":
            results = self.combat_system.player_attack()
        elif action == "defend":
            results = self.combat_system.player_defend()
        elif action == "flee":
            results = self.combat_system.player_flee()
        else:
            return {"success": False, "message": f"Unknown combat action: {action}"}
            
        # If combat is still active after player action, process enemy turn
        if self.combat_system.combat_active:
            enemy_results = self.combat_system.enemy_attack()
            
            # Combine results
            results["enemy_action"] = enemy_results
            
        return results
```

## CREW MANAGEMENT SYSTEM (#crew_management_system)

The crew management system handles the recruitment, assignment, and management of crew members on the player's ship, providing skill-based bonuses and specialized station management.

### Core Crew Management Structure

```python
class CrewManagementSystem:
    """System for managing crew members and their assignments to ship stations."""

    def __init__(self):
        """Initialize the crew management system."""
        self.crew_members = {}  # Dict of crew_id: CrewMember
        self.station_assignments = {station: [] for station in STATION_TYPES}
        self.max_crew_size = 10  # Maximum number of crew members
        self.max_per_station = {  # Maximum crew per station
            "navigation": 2,
            "engineering": 3,
            "weapons": 2,
            "science": 2,
            "medical": 2,
            "command": 1,
        }

    def add_crew_member(self, crew_member: CrewMember) -> Dict[str, Any]:
        """Add a crew member to the roster."""
        # Implementation details...
        
    def remove_crew_member(self, crew_id: str) -> Dict[str, Any]:
        """Remove a crew member from the roster."""
        # Implementation details...
        
    def assign_to_station(self, crew_id: str, station: str) -> Dict[str, Any]:
        """Assign a crew member to a station."""
        # Implementation details...
        
    def unassign_from_station(self, crew_id: str, station: str) -> Dict[str, Any]:
        """Unassign a crew member from a station."""
        # Implementation details...
        
    def get_station_bonus(self, station: str) -> float:
        """Calculate the total bonus provided by crew at a station."""
        # Implementation details...
```

### Crew Member Representation

```python
class CrewMember:
    """Represents a recruitable crew member with skills and specializations."""

    def __init__(
        self,
        crew_id: Optional[str] = None,
        name: str = None,
        specialization: str = None,
        level: int = 1,
    ):
        """Initialize a crew member."""
        self.crew_id = crew_id or f"crew_{random.randint(1000, 9999)}"
        self.name = name or self._generate_name()
        self.specialization = specialization or random.choice(list(STATION_TYPES))
        self.level = level
        self.experience = 0
        self.max_experience = level * 100
        
        # Skills range from 1-100
        self.skills = {
            "navigation": random.randint(10, 30),
            "engineering": random.randint(10, 30),
            "weapons": random.randint(10, 30),
            "science": random.randint(10, 30),
            "medical": random.randint(10, 30),
            "command": random.randint(10, 30),
        }
        
        # Boost skill in specialization
        self.skills[self.specialization] += 20
        
        # Personal attributes
        self.morale = 100.0  # 0-100
        self.health = 100.0  # 0-100
        self.fatigue = 0.0   # 0-100
        self.salary = 10 * level  # Credits per day
        
        # Current assignment
        self.current_station = None
        self.time_at_station = 0.0
        
        # Career stats
        self.days_served = 0
        self.successful_missions = 0
        self.injuries = 0
```

### Station Management

```python
def assign_to_station(self, crew_id: str, station: str) -> Dict[str, Any]:
    """Assign a crew member to a station."""
    # Verify crew exists
    if crew_id not in self.crew_members:
        return {
            "success": False,
            "message": f"Crew member {crew_id} not found",
        }
        
    # Verify station is valid
    if station not in STATION_TYPES:
        return {
            "success": False,
            "message": f"Invalid station type: {station}",
        }
        
    crew_member = self.crew_members[crew_id]
    
    # Check if station has room
    if len(self.station_assignments[station]) >= self.max_per_station[station]:
        return {
            "success": False,
            "message": f"Station {station} is at maximum capacity",
        }
        
    # If crew is assigned elsewhere, unassign first
    if crew_member.current_station:
        self.unassign_from_station(crew_id, crew_member.current_station)
        
    # Assign to station
    self.station_assignments[station].append(crew_id)
    crew_member.current_station = station
    crew_member.time_at_station = 0.0
    
    # Calculate new station bonus
    station_bonus = self.get_station_bonus(station)
    
    return {
        "success": True,
        "message": f"Assigned {crew_member.name} to {station}",
        "new_station_bonus": station_bonus,
    }
```

### Crew Skill System

```python
def get_station_bonus(self, station: str) -> float:
    """Calculate the total bonus provided by crew at a station."""
    if station not in STATION_TYPES:
        return 0.0
        
    total_skill = 0.0
    crew_count = len(self.station_assignments[station])
    
    if crew_count == 0:
        return 0.0
        
    # Sum up relevant skills of all crew at station
    for crew_id in self.station_assignments[station]:
        if crew_id in self.crew_members:
            crew = self.crew_members[crew_id]
            skill_value = crew.skills[station]
            
            # Specialization bonus
            if crew.specialization == station:
                skill_value *= 1.25  # 25% bonus for specialization
                
            # Fatigue penalty
            if crew.fatigue > 50.0:
                fatigue_penalty = (crew.fatigue - 50.0) / 100.0
                skill_value *= (1.0 - fatigue_penalty)
                
            # Morale modifier
            morale_modifier = (crew.morale / 100.0) * 0.2 + 0.9  # 0.9-1.1 range
            skill_value *= morale_modifier
            
            total_skill += skill_value
    
    # Convert to a percentage bonus (0.0-1.0)
    # The formula ensures diminishing returns for stacking multiple crew
    bonus = (total_skill / 100.0) * (1.0 / math.sqrt(crew_count))
    
    # Cap at reasonable maximum
    return min(bonus, 1.0)
```

### Crew Management Integration Pattern

```python
class GameContext:
    def __init__(self):
        # Initialize player
        self.player = Player(player_id="player_1", name="Captain")
        
        # Initialize crew management system
        self.crew_system = CrewManagementSystem()
        
        # Add starting crew
        starting_crew = CrewMember(
            name="First Mate Jenkins",
            specialization="command",
            level=2
        )
        self.crew_system.add_crew_member(starting_crew)
        self.crew_system.assign_to_station(starting_crew.crew_id, "command")
        
    def update(self, dt: float):
        # Update crew states
        for crew_id, crew in self.crew_system.crew_members.items():
            # Update fatigue based on time at station
            if crew.current_station:
                crew.time_at_station += dt
                fatigue_increase = dt * 0.5  # 0.5% fatigue per second
                crew.fatigue = min(100.0, crew.fatigue + fatigue_increase)
            
            # Rest crew not at stations
            else:
                fatigue_decrease = dt * 1.0  # 1% recovery per second
                crew.fatigue = max(0.0, crew.fatigue - fatigue_decrease)
        
        # Apply crew bonuses to ship systems
        navigation_bonus = self.crew_system.get_station_bonus("navigation")
        self.player.ship.navigation_efficiency = 1.0 + navigation_bonus
        
        engineering_bonus = self.crew_system.get_station_bonus("engineering")
        self.player.ship.repair_efficiency = 1.0 + engineering_bonus
        
        weapons_bonus = self.crew_system.get_station_bonus("weapons")
        self.player.ship.weapon_efficiency = 1.0 + weapons_bonus
```

## TRADING SYSTEM (#trading_system)

The trading system handles resource trading, market dynamics, dynamic pricing, and economic interactions within the game universe.

### Core Trading System Structure

```python
class TradingSystem:
    """Core class that manages the trading system, including market mechanics,
    price fluctuations, and trading stations."""

    def __init__(self) -> None:
        """Initialize the trading system with default commodities and stations."""
        # Initialize base commodities with their default prices
        self.commodities = {
            "common_minerals": {
                "base_price": 10,
                "volatility": 0.1,  # How much prices fluctuate (0-1)
                "current_price": 10,
                "supply": 1.0,  # Supply factor (< 1 = shortage, > 1 = surplus)
                "description": "Common minerals used in basic manufacturing.",
            },
            "rare_minerals": {
                "base_price": 30,
                "volatility": 0.2,
                "current_price": 30,
                "supply": 1.0,
                "description": "Rare minerals with unique properties, valuable for advanced technology.",
            },
            # Additional commodities...
        }
        
        # Trading stations across the game universe
        self.stations = {}
        
        # Market events that influence prices
        self.active_events = []
        
        # Trading history for analytics
        self.trade_history = []
        
        # Economy simulation parameters
        self.economy_factor = 1.0  # Global economic health
        self.update_interval = 1.0  # Hours between market updates
        self.last_update = 0.0
        
        # Initialize base stations
        self._initialize_stations()

    def buy_commodity(self, station_id: str, commodity: str, amount: int) -> Dict[str, Any]:
        """Buy a commodity from a trading station."""
        # Implementation details...
        
    def sell_commodity(self, station_id: str, commodity: str, amount: int) -> Dict[str, Any]:
        """Sell a commodity to a trading station."""
        # Implementation details...
        
    def update_prices(self, dt: float) -> None:
        """Update commodity prices based on time, events, and market forces."""
        # Implementation details...
        
    def add_station(self, station_id: str, position: Tuple[int, int], economy_type: str = "balanced") -> None:
        """Add a new trading station to the system."""
        # Implementation details...
        
    def get_price_at_station(self, station_id: str, commodity: str) -> float:
        """Get the current price of a commodity at a specific station."""
        # Implementation details...
```

### Station and Economy Types

```python
# Economy types define characteristics of trading stations
ECONOMY_TYPES = {
    "industrial": {
        "buy_modifiers": {"common_minerals": 0.8, "rare_minerals": 0.9, "fuel": 0.9},
        "sell_modifiers": {"industrial_goods": 1.1, "luxury_goods": 0.9, "technology": 1.1},
        "supply_modifiers": {"industrial_goods": 1.3, "technology": 1.1},
        "description": "Manufacturing hub with high demand for minerals and energy."
    },
    "agricultural": {
        "buy_modifiers": {"food": 0.7, "organic_matter": 0.8, "water": 0.9},
        "sell_modifiers": {"food": 1.2, "luxuries": 0.9, "medical_supplies": 1.0},
        "supply_modifiers": {"food": 1.5, "organic_matter": 1.3},
        "description": "Food production center with abundant organic resources."
    },
    "technological": {
        "buy_modifiers": {"rare_minerals": 0.8, "technology": 0.9, "data": 0.7},
        "sell_modifiers": {"technology": 1.2, "industrial_goods": 1.0, "luxury_goods": 1.0},
        "supply_modifiers": {"technology": 1.3, "data": 1.2},
        "description": "Advanced research and development center."
    },
    "mining": {
        "buy_modifiers": {"industrial_goods": 0.9, "fuel": 0.8, "food": 0.9},
        "sell_modifiers": {"common_minerals": 1.2, "rare_minerals": 1.3, "anomalous_materials": 1.1},
        "supply_modifiers": {"common_minerals": 1.4, "rare_minerals": 1.2},
        "description": "Resource extraction outpost with abundant minerals."
    },
    "trading": {
        "buy_modifiers": {"all": 0.95},  # Slightly better prices for all commodities
        "sell_modifiers": {"all": 1.05},
        "supply_modifiers": {"all": 1.1},
        "description": "Commercial hub with diverse market offerings."
    },
    "balanced": {  # Default type
        "buy_modifiers": {"all": 1.0},
        "sell_modifiers": {"all": 1.0},
        "supply_modifiers": {"all": 1.0},
        "description": "Balanced economy with standard market conditions."
    }
}
```

### Dynamic Price Calculation

```python
def update_prices(self, dt: float) -> None:
    """Update commodity prices based on time, events, and market forces."""
    # Check if it's time for an update
    self.last_update += dt
    if self.last_update < self.update_interval:
        return
        
    self.last_update = 0.0
    
    # Process any active events that affect the economy
    event_modifiers = self._process_events()
    
    # Update prices for each commodity at each station
    for station_id, station in self.stations.items():
        economy_type = station["economy_type"]
        
        for commodity, data in self.commodities.items():
            # Base price and volatility
            base_price = data["base_price"]
            volatility = data["volatility"]
            
            # Station-specific supply and demand factors
            supply_factor = station["commodities"].get(commodity, {}).get("supply", 1.0)
            
            # Economy type modifiers
            economy_modifiers = ECONOMY_TYPES.get(economy_type, ECONOMY_TYPES["balanced"])
            sell_modifier = economy_modifiers["sell_modifiers"].get(
                commodity, economy_modifiers["sell_modifiers"].get("all", 1.0)
            )
            
            # Event modifiers for this commodity
            event_modifier = event_modifiers.get(commodity, 1.0)
            
            # Random market fluctuation based on volatility
            fluctuation = 1.0 + (random.uniform(-1.0, 1.0) * volatility)
            
            # Calculate new price
            new_price = base_price * sell_modifier * event_modifier * fluctuation
            
            # Apply supply and demand adjustments
            if supply_factor < 1.0:  # Shortage increases prices
                new_price *= (2.0 - supply_factor)
            elif supply_factor > 1.0:  # Surplus decreases prices
                new_price *= (1.0 / supply_factor)
                
            # Update supply slightly toward equilibrium
            new_supply = supply_factor * 0.95 + 1.0 * 0.05  # Tends toward 1.0
            
            # Apply global economy factor
            new_price *= self.economy_factor
            
            # Ensure prices have some minimum
            new_price = max(1.0, new_price)
            
            # Update station's commodity data
            station["commodities"].setdefault(commodity, {
                "current_price": new_price,
                "supply": new_supply,
                "last_update": 0.0
            })
            station["commodities"][commodity]["current_price"] = new_price
            station["commodities"][commodity]["supply"] = new_supply
```

### Market Events System

```python
def create_market_event(self, event_type: str, duration: float, affected_commodities: List[str] = None) -> Dict[str, Any]:
    """Create a market event that influences commodity prices."""
    # Define event types and their impacts
    event_types = {
        "shortage": {
            "description": "Supply shortage driving up prices",
            "price_modifier": 1.5,  # 50% price increase
            "supply_modifier": 0.5,  # 50% supply reduction
        },
        "surplus": {
            "description": "Market surplus driving down prices",
            "price_modifier": 0.6,  # 40% price reduction
            "supply_modifier": 1.5,  # 50% supply increase
        },
        "disruption": {
            "description": "Trade route disruption affecting logistics",
            "price_modifier": 1.25,  # 25% price increase
            "supply_modifier": 0.75,  # 25% supply reduction
        },
        "speculation": {
            "description": "Market speculation causing price volatility",
            "price_modifier": lambda: random.uniform(0.7, 1.4),  # Varying price impact
            "supply_modifier": 1.0,  # No supply impact
        },
        "technology": {
            "description": "Technological breakthrough",
            "price_modifier": 0.8,  # 20% price reduction
            "supply_modifier": 1.2,  # 20% supply increase
        },
    }
    
    if event_type not in event_types:
        return {"success": False, "message": f"Unknown event type: {event_type}"}
    
    # If no specific commodities, apply to random selection
    if not affected_commodities:
        all_commodities = list(self.commodities.keys())
        num_affected = random.randint(1, min(3, len(all_commodities)))
        affected_commodities = random.sample(all_commodities, num_affected)
    
    # Create event record
    event = {
        "type": event_type,
        "description": event_types[event_type]["description"],
        "affected_commodities": affected_commodities,
        "price_modifier": event_types[event_type]["price_modifier"],
        "supply_modifier": event_types[event_type]["supply_modifier"],
        "duration": duration,  # Hours remaining
        "start_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }
    
    # Add to active events
    self.active_events.append(event)
    
    # Log event creation
    logging.info(f"Market event created: {event_type} affecting {affected_commodities}")
    
    return {
        "success": True,
        "message": f"Market event created: {event_type}",
        "event": event,
    }
```

### Trading Interface Implementation

```python
def buy_commodity(self, station_id: str, commodity: str, amount: int, player=None) -> Dict[str, Any]:
    """Buy a commodity from a trading station."""
    # Validate inputs
    if station_id not in self.stations:
        return {"success": False, "message": f"Station {station_id} not found"}
        
    if commodity not in self.commodities:
        return {"success": False, "message": f"Unknown commodity: {commodity}"}
        
    if amount <= 0:
        return {"success": False, "message": "Amount must be positive"}
        
    station = self.stations[station_id]
    station_commodity = station["commodities"].get(commodity, {})
    
    if not station_commodity:
        return {"success": False, "message": f"{commodity} not available at this station"}
        
    # Calculate price with economy type modifier
    economy_type = station["economy_type"]
    economy_modifiers = ECONOMY_TYPES.get(economy_type, ECONOMY_TYPES["balanced"])
    buy_modifier = economy_modifiers["buy_modifiers"].get(
        commodity, economy_modifiers["buy_modifiers"].get("all", 1.0)
    )
    
    price_per_unit = station_commodity.get("current_price", self.commodities[commodity]["base_price"])
    total_price = price_per_unit * amount * buy_modifier
    
    # Check if player can afford it
    if player and hasattr(player, "credits") and player.credits < total_price:
        return {
            "success": False,
            "message": f"Insufficient credits. Need {total_price}, have {player.credits}",
            "price": total_price,
            "credits": player.credits,
        }
        
    # Process transaction
    if player:
        # Deduct credits
        if hasattr(player, "remove_credits"):
            player.remove_credits(total_price)
            
        # Add to inventory
        if hasattr(player, "add_to_inventory"):
            player.add_to_inventory(commodity, amount)
    
    # Update station's supply
    supply_factor = station_commodity.get("supply", 1.0)
    new_supply = max(0.5, supply_factor - (amount * 0.01))  # Buying reduces supply
    station["commodities"][commodity]["supply"] = new_supply
    
    # Record transaction
    self.trade_history.append({
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "type": "buy",
        "station": station_id,
        "commodity": commodity,
        "amount": amount,
        "price_per_unit": price_per_unit,
        "total_price": total_price,
        "player": player.player_id if player and hasattr(player, "player_id") else None,
    })
    
    return {
        "success": True,
        "message": f"Purchased {amount} {commodity} for {total_price} credits",
        "price": total_price,
        "commodity": commodity,
        "amount": amount,
        "station": station_id,
    }
```

## DEPENDENCY INJECTION SYSTEM (#dependency_system)

Space Muck implements a flexible dependency injection system to manage component dependencies, facilitate testing, and support modular architecture. This system reduces coupling between components and improves maintainability.

### Service Container Implementation

```python
class ServiceContainer:
    """Container for managing service dependencies."""

    def __init__(self):
        """Initialize an empty service container."""
        self._services = {}
        self._factories = {}
        self._singletons = set()
        self._instances = {}
        
    def register(self, service_type: type, implementation=None, *, factory=None, singleton=False):
        """Register a service with the container."""
        if factory is not None:
            # Register a factory function
            self._factories[service_type] = factory
        else:
            # Register a concrete implementation class
            self._services[service_type] = implementation or service_type
            
        if singleton:
            self._singletons.add(service_type)
            
        return self
        
    def resolve(self, service_type: type):
        """Resolve a service from the container."""
        # Check for existing singleton instance
        if service_type in self._singletons and service_type in self._instances:
            return self._instances[service_type]
            
        # Resolve via factory if registered
        if service_type in self._factories:
            instance = self._factories[service_type](self)
            
            # Cache singleton instances
            if service_type in self._singletons:
                self._instances[service_type] = instance
                
            return instance
            
        # Resolve via implementation class
        if service_type in self._services:
            implementation = self._services[service_type]
            
            # Use inspection to identify constructor parameters
            signature = inspect.signature(implementation.__init__)
            parameters = {}
            
            for param_name, param in signature.parameters.items():
                if param_name == 'self':
                    continue
                    
                # Extract parameter type hint
                if param.annotation != inspect.Parameter.empty:
                    param_type = param.annotation
                    parameters[param_name] = self.resolve(param_type)
                elif param.default != inspect.Parameter.empty:
                    # Use default value if provided
                    pass
                else:
                    raise DependencyResolutionError(
                        f"Cannot resolve parameter '{param_name}' for {implementation.__name__}"
                    )
            
            instance = implementation(**parameters)
            
            # Cache singleton instances
            if service_type in self._singletons:
                self._instances[service_type] = instance
                
            return instance
            
        raise ServiceNotRegisteredError(f"Service {service_type.__name__} not registered")
```

### Interface-based Dependency Pattern

```python
class IGameState(Protocol):
    """Interface for game state management."""
    
    def get_state(self) -> str:
        """Get the current game state."""
        ...
        
    def change_state(self, new_state: str) -> bool:
        """Change the game state."""
        ...
        
    def get_state_history(self) -> List[Dict[str, Any]]:
        """Get the state transition history."""
        ...


class IResourceManager(Protocol):
    """Interface for resource management."""
    
    def load_resource(self, resource_id: str) -> Any:
        """Load a resource by ID."""
        ...
        
    def unload_resource(self, resource_id: str) -> bool:
        """Unload a resource by ID."""
        ...
        
    def get_resource_info(self, resource_id: str) -> Dict[str, Any]:
        """Get information about a resource."""
        ...
```

### Performance Monitoring System

```python
# Game loop performance monitoring
def _monitor_performance(self, delta_time: float) -> None:
    """Monitor and log performance metrics."""
    # Memory usage logging (every 100 frames)
    if self.frame_counter % 100 == 0:
        log_memory_usage()

    # FPS calculation
    if delta_time > 0:
        self._update_fps_history(delta_time)

# Performance logging utilities
def log_performance_start(tag: str) -> float:
    """Start timing a code section."""
    logging.debug(f"PERF START: {tag}")
    return time.time()

def log_performance_end(tag: str, start_time: float) -> float:
    """End timing a code section and log the duration."""
    end_time = time.time()
    duration = (end_time - start_time) * 1000.0  # Convert to milliseconds
    logging.debug(f"PERF END: {tag} took {duration:.2f}ms")
    return duration
```

### Algorithm Optimization

```python
# Optimized cellular automaton with multiple backends
def apply_cellular_automaton_optimized(
    grid: np.ndarray,
    birth_set: Set[int] = None,
    survival_set: Set[int] = None,
    iterations: int = 3,
    wrap: bool = True,
) -> np.ndarray:
    """Apply cellular automaton rules using optimized implementation."""
    # Fast path using scipy if available
    if SCIPY_AVAILABLE:
        return _apply_convolution_based_cellular_automaton(
            grid, birth_set, survival_set, iterations
        )
    else:
        # Fall back to standard implementation
        return apply_cellular_automaton(
            grid, birth_set, survival_set, iterations, wrap
        )

def _apply_convolution_based_cellular_automaton(
    grid: np.ndarray,
    birth_set: Set[int],
    survival_set: Set[int],
    iterations: int,
) -> np.ndarray:
    """Apply cellular automaton rules using fast convolution method."""
    # Use scipy's convolve2d for efficient neighbor counting
    kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
    result = grid.copy()
    
    for _ in range(iterations):
        # Count neighbors using convolution
        with LogContext("convolve") as _:
            neighbors = ndimage.convolve(result, kernel, mode='wrap')
        
        # Apply rules to determine next state
        binary_grid = result.astype(bool)
        born = np.isin(neighbors, list(birth_set)) & ~binary_grid
        survive = np.isin(neighbors, list(survival_set)) & binary_grid
        result = np.logical_or(born, survive).astype(np.int8)
    
    return result
```

### Memory Management

```python
# Context manager for tracking performance and automatically releasing resources
class LogContext:
    """Context manager for tracking performance and logging exceptions."""

    def __init__(self, context_name: str, log_level: int = logging.DEBUG):
        """Initialize with a context name and log level."""
        self.context_name = context_name
        self.log_level = log_level
        self.start_time = None

    def __enter__(self):
        """Start timing when entering the context."""
        self.start_time = time.time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Log timing and any exceptions when exiting the context."""
        duration = (time.time() - self.start_time) * 1000.0  # Convert to ms
        logging.log(
            self.log_level,
            f"CONTEXT: {self.context_name} completed in {duration:.2f}ms",
        )

        # Log any exception that occurred and let it propagate
        if exc_type is not None:
            logging.exception(f"Exception in {self.context_name}: {exc_val}")
            return False  # Don't suppress the exception

def log_memory_usage(tag: str = "Memory check") -> Optional[float]:
    """Log current memory usage."""
    try:
        import psutil
        process = psutil.Process(os.getpid())
        memory_info = process.memory_info()
        memory_mb = memory_info.rss / (1024 * 1024)  # Convert bytes to MB
        logging.debug(f"MEMORY[{tag}]: {memory_mb:.2f} MB")
        return memory_mb
    except ImportError:
        logging.debug(f"MEMORY[{tag}]: psutil not available for memory monitoring")
        return None
```

## STATE SYSTEM (#state_system)

Space Muck implements a comprehensive state management system for tracking and controlling game state transitions. This system ensures proper validation, actions execution, and error handling during state changes.

### Related Systems
- **[AI System](#ai_system)** - AI behaviors respond to game state changes
- **[Event System](#event_system)** - Events are triggered on state transitions
- **[Context System](#context_system)** - State is managed through context providers
- **[Testing System](#testing_system)** - State transitions are tested for reliability

### State Transition Management

```python
@dataclass
class StateTransition:
    """Represents a state transition with timing information."""

    from_state: str
    to_state: str
    timestamp: datetime
    duration: float
    success: bool
    error: Optional[str] = None


class Game:
    """Main game class with enhanced state management."""

    def __init__(self):
        """Initialize the game with state management."""
        self._state = GAME_CONFIG["initial_state"]
        self._state_history: List[StateTransition] = []
        self._state_valid = True
        self._transition_handlers: Dict[str, Dict[str, Callable]] = {}
        self._validation_handlers: Dict[str, List[Callable]] = {}
        self._entry_handlers: Dict[str, List[Callable]] = {}
        self._exit_handlers: Dict[str, List[Callable]] = {}
        self._setup_handlers()
        self._logger = logging.getLogger(__name__)

    def change_state(self, new_state: str) -> None:
        """Change the game state with validation and history tracking."""
        start_time = time.time()
        transition = StateTransition(
            from_state=self._state,
            to_state=new_state,
            timestamp=datetime.now(),
            duration=0.0,  # Will be updated if successful
            success=False, # Will be updated if successful
        )

        try:
            # Validate the state transition
            self._validate_state_transition(new_state)
            
            # Execute exit actions for current state
            self._execute_state_actions(self._state, "exit")
            
            # Change state
            old_state = self._state
            self._state = new_state
            
            # Execute entry actions for new state
            self._execute_state_actions(new_state, "entry")
            
            # Record successful transition
            duration = time.time() - start_time
            transition.duration = duration
            transition.success = True
            self._state_history.append(transition)
            
        except GameStateError as e:
            # Record failed transition
            transition.error = str(e)
            transition.duration = time.time() - start_time
            self._state_history.append(transition)
            raise
```

### State Validation

```python
def _validate_state_transition(self, new_state: str) -> bool:
    """Validate if a state transition is allowed."""
    if new_state not in GAME_CONFIG["states"]:
        raise InvalidStateTransitionError(f"Invalid state: {new_state}")

    current_state_config = GAME_CONFIG["states"][self._state]
    if new_state not in current_state_config["allowed_transitions"]:
        raise InvalidStateTransitionError(
            f"Cannot transition from {self._state} to {new_state}"
        )

    # Run validation rules for the new state
    new_state_config = GAME_CONFIG["states"][new_state]
    for rule in new_state_config["validation_rules"]:
        if (
            rule in self._validation_handlers
            and not self._validation_handlers[rule]()
        ):
            raise StateValidationError(f"Validation failed: {rule}")

    return True
```

### Error Handling

```python
class GameStateError(Exception):
    """Base exception for game state errors."""
    pass


class InvalidStateTransitionError(GameStateError):
    """Raised when an invalid state transition is attempted."""
    pass


class StateValidationError(GameStateError):
    """Raised when state validation fails."""
    pass
```

### State History and Debugging

```python
def get_state_history(self) -> List[StateTransition]:
    """Return the complete state transition history."""
    return self._state_history.copy()


def get_state_statistics(self) -> Dict[str, Any]:
    """Calculate and return statistics about state transitions."""
    if not self._state_history:
        return {"transitions": 0}
        
    transitions = len(self._state_history)
    successes = sum(1 for t in self._state_history if t.success)
    failures = transitions - successes
    avg_duration = sum(t.duration for t in self._state_history) / transitions
    
    # Group transitions by type
    transition_types = {}
    for t in self._state_history:
        key = f"{t.from_state}->{t.to_state}"
        if key not in transition_types:
            transition_types[key] = 0
        transition_types[key] += 1
        
    return {
        "transitions": transitions,
        "successes": successes,
        "failures": failures,
        "success_rate": successes / transitions if transitions > 0 else 0,
        "avg_duration": avg_duration,
        "transition_types": transition_types,
        "current_state": self._state,
    }
```

## SHIP SYSTEM (#ship_system)

Space Muck implements a comprehensive ship management system for player and NPC vessels. This system provides functionality for ship configuration, component management, upgrades, and performance characteristics.

### Related Systems
- **[AI System](#ai_system)** - AI agents control ships and utilize ship components
- **[Component System](#component_system)** - Ship uses component patterns for modular functionality
- **[Event System](#event_system)** - Ship events for damage, upgrades, and status changes
- **[Performance System](#performance_system)** - Ships optimize rendering and physics updates

### Ship Components and Structure

```python
class ShipComponent:
    """Base class for all ship components."""
    
    def __init__(self, component_id: str, name: str, level: int = 1, durability: float = 100.0):
        """Initialize a ship component."""
        self.component_id = component_id
        self.name = name
        self.level = level
        self.durability = durability
        self.max_durability = durability
        self.active = True
        self.tags = set()
        
    def damage(self, amount: float) -> float:
        """Apply damage to the component and return the remaining durability."""
        self.durability = max(0.0, self.durability - amount)
        if self.durability <= 0:
            self.active = False
        return self.durability
        
    def repair(self, amount: float) -> float:
        """Repair the component and return the new durability."""
        self.durability = min(self.max_durability, self.durability + amount)
        if self.durability > 0:
            self.active = True
        return self.durability
        
    def upgrade(self) -> bool:
        """Upgrade the component to the next level."""
        self.level += 1
        self.max_durability *= 1.2  # 20% increase per level
        self.durability = self.max_durability
        return True
```

### Ship Class Implementation

```python
class Ship:
    """Represents a ship with modular components and performance characteristics."""
    
    def __init__(self, ship_id: str, name: str, ship_class: str = "standard"):
        """Initialize a ship with base attributes."""
        self.ship_id = ship_id
        self.name = name
        self.ship_class = ship_class
        self.components = {}
        self.position = (0, 0)
        self.velocity = (0, 0)
        self.heading = 0.0  # degrees, 0 = north, 90 = east
        self.energy = 100.0
        self.max_energy = 100.0
        self.crew = []
        self.cargo = {}
        self.active = True
        
    def add_component(self, component_type: str, component: ShipComponent) -> bool:
        """Add a component to the ship."""
        if component_type not in self.components:
            self.components[component_type] = []
        self.components[component_type].append(component)
        return True
        
    def remove_component(self, component_type: str, component_id: str) -> ShipComponent:
        """Remove a component from the ship."""
        if component_type in self.components:
            for i, component in enumerate(self.components[component_type]):
                if component.component_id == component_id:
                    return self.components[component_type].pop(i)
        return None
```

### Ship Movement and Navigation

```python
def move_ship(self, delta_time: float) -> Tuple[float, float]:
    """Update ship position based on velocity and heading."""
    # Apply velocity to position
    dx = self.velocity[0] * delta_time
    dy = self.velocity[1] * delta_time
    self.position = (self.position[0] + dx, self.position[1] + dy)
    
    # Apply drag to slow down the ship naturally
    drag_factor = self._calculate_drag()
    if abs(self.velocity[0]) > 0.01 or abs(self.velocity[1]) > 0.01:
        new_vx = self.velocity[0] * drag_factor
        new_vy = self.velocity[1] * drag_factor
        self.velocity = (new_vx, new_vy)
    
    return self.position

def accelerate(self, thrust: float, delta_time: float) -> Tuple[float, float]:
    """Apply thrust in the direction of the ship's heading."""
    # Convert heading to radians and calculate thrust components
    heading_rad = math.radians(self.heading)
    thrust_x = thrust * math.sin(heading_rad) * delta_time
    thrust_y = thrust * math.cos(heading_rad) * delta_time
    
    # Apply thrust to velocity
    vx, vy = self.velocity
    self.velocity = (vx + thrust_x, vy + thrust_y)
    
    # Use energy for thrust
    energy_cost = thrust * SHIP_CONFIG["energy_thrust_ratio"] * delta_time
    self.energy = max(0.0, self.energy - energy_cost)
    
    return self.velocity
```

### Ship Combat and Damage System

```python
def fire_weapon(self, weapon_id: str, target: Ship) -> Tuple[bool, float]:
    """Fire a weapon at a target ship and return hit success and damage dealt."""
    # Find the weapon component
    weapon = None
    for component in self.components.get("weapons", []):
        if component.component_id == weapon_id and component.active:
            weapon = component
            break
            
    if not weapon:
        return False, 0.0
        
    # Calculate energy cost and check if we have enough
    energy_cost = weapon.energy_cost
    if self.energy < energy_cost:
        return False, 0.0
        
    # Use energy
    self.energy -= energy_cost
    
    # Calculate hit chance based on distance, relative velocity, and weapon accuracy
    distance = math.sqrt(
        (self.position[0] - target.position[0])**2 + 
        (self.position[1] - target.position[1])**2
    )
    
    # Calculate hit probability
    hit_chance = weapon.accuracy * (1.0 - min(1.0, distance / weapon.range))
    
    # Determine if the shot hits
    hit = random.random() < hit_chance
    
    if not hit:
        return False, 0.0
        
    # Calculate damage
    damage = weapon.damage * (0.8 + 0.4 * random.random())
    
    # Apply damage to a random component on the target
    target.take_damage(damage)
    
    return True, damage

def take_damage(self, damage: float) -> List[ShipComponent]:
    """Take damage to the ship and return damaged components."""
    damaged_components = []
    
    # Get all components in a flat list
    all_components = []
    for component_list in self.components.values():
        all_components.extend(component_list)
        
    if not all_components:
        return damaged_components
        
    # Select a random component to damage
    component = random.choice(all_components)
    remaining = component.damage(damage)
    damaged_components.append(component)
    
    # If there's excess damage, apply it to another component
    if remaining <= 0 and damage > component.max_durability:
        excess_damage = damage - component.max_durability
        if excess_damage > 0 and len(all_components) > 1:
            # Get components excluding the already damaged one
            remaining_components = [c for c in all_components if c != component]
            if remaining_components:
                second_component = random.choice(remaining_components)
                second_component.damage(excess_damage * 0.5)  # Reduced damage for splash
                damaged_components.append(second_component)
    
    return damaged_components
```

## AI SYSTEM (#ai_system)

Space Muck implements an AI system for controlling non-player ships, managing enemy behavior, and providing adaptive challenges to players. The AI system includes decision trees, behavior patterns, and difficulty scaling.

### Related Systems
- **[Ship System](#ship_system)** - AI agents control ship entities and use ship components
- **[State System](#state_system)** - AI behavior responds to game state changes
- **[Event System](#event_system)** - AI agents subscribe to relevant game events
- **[Performance System](#performance_system)** - AI behavior trees are optimized for performance

### AI Agent Base Structure

```python
class AIAgent:
    """Base class for all AI agents in the game."""
    
    def __init__(self, agent_id: str, difficulty: float = 1.0):
        """Initialize an AI agent with basic attributes."""
        self.agent_id = agent_id
        self.difficulty = difficulty  # 1.0 = normal, <1.0 easier, >1.0 harder
        self.entity = None  # The game entity this AI controls
        self.knowledge_base = {}  # What this AI knows about the world
        self.behavior_tree = None  # Decision-making tree
        self.target = None  # Current target if any
        self.state = "idle"  # Current AI state
        self.last_decision_time = 0.0  # When the AI last made a decision
        self.decision_cooldown = 0.5  # Seconds between decision points
        
    def set_entity(self, entity) -> None:
        """Set the game entity this AI will control."""
        self.entity = entity
        
    def update(self, game_state, delta_time: float) -> None:
        """Update the AI agent's state and make decisions."""
        # Skip if we're on cooldown
        current_time = time.time()
        if current_time - self.last_decision_time < self.decision_cooldown:
            return
            
        self.last_decision_time = current_time
        
        # Update knowledge about the world
        self._update_knowledge(game_state)
        
        # Execute the behavior tree
        if self.behavior_tree:
            self.behavior_tree.execute(self, game_state, delta_time)
            
    def _update_knowledge(self, game_state) -> None:
        """Update the AI's knowledge about the game world."""
        # Base implementation just stores nearby entities
        if self.entity:
            self.knowledge_base["nearby_entities"] = []
            position = self.entity.position
            perception_range = 200.0 * self.difficulty  # Higher difficulty = better perception
            
            for entity in game_state.entities:
                if entity.entity_id == self.entity.entity_id:
                    continue  # Skip self
                    
                distance = math.sqrt(
                    (position[0] - entity.position[0])**2 +
                    (position[1] - entity.position[1])**2
                )
                
                if distance <= perception_range:
                    self.knowledge_base["nearby_entities"].append({
                        "entity": entity,
                        "distance": distance,
                        "bearing": self._calculate_bearing(entity.position),
                    })
                    
    def _calculate_bearing(self, target_position) -> float:
        """Calculate bearing to target position in degrees."""
        if not self.entity:
            return 0.0
            
        dx = target_position[0] - self.entity.position[0]
        dy = target_position[1] - self.entity.position[1]
        
        # Calculate bearing in degrees (0 = north, 90 = east)
        bearing = math.degrees(math.atan2(dx, dy)) % 360
        return bearing
```

### Behavior Tree Implementation

```python
class BehaviorNode:
    """Base class for all behavior tree nodes."""
    
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Execute this node's behavior and return success/failure."""
        return True  # Base implementation always succeeds


class SequenceNode(BehaviorNode):
    """A node that executes child nodes in sequence until one fails."""
    
    def __init__(self, children: List[BehaviorNode]):
        """Initialize with child nodes."""
        self.children = children
        
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Execute all child nodes in sequence until one fails."""
        for child in self.children:
            if not child.execute(agent, game_state, delta_time):
                return False  # Child failed, sequence fails
        return True  # All children succeeded


class SelectorNode(BehaviorNode):
    """A node that executes child nodes until one succeeds."""
    
    def __init__(self, children: List[BehaviorNode]):
        """Initialize with child nodes."""
        self.children = children
        
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Execute child nodes until one succeeds."""
        for child in self.children:
            if child.execute(agent, game_state, delta_time):
                return True  # Child succeeded, selector succeeds
        return False  # All children failed


class InverterNode(BehaviorNode):
    """A node that inverts the result of its child node."""
    
    def __init__(self, child: BehaviorNode):
        """Initialize with a child node."""
        self.child = child
        
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Execute child and return the inverse of its result."""
        return not self.child.execute(agent, game_state, delta_time)


class ConditionNode(BehaviorNode):
    """A node that evaluates a condition function."""
    
    def __init__(self, condition_func):
        """Initialize with a condition function."""
        self.condition_func = condition_func
        
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Execute condition function and return its result."""
        return self.condition_func(agent, game_state)
```

### Common AI Behaviors

```python
class FindTargetNode(BehaviorNode):
    """Find and set a target for the AI to engage."""
    
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Find the nearest valid target."""
        nearby = agent.knowledge_base.get("nearby_entities", [])
        
        # Filter to only include valid targets (e.g., enemy ships)
        valid_targets = []
        for entity_data in nearby:
            entity = entity_data["entity"]
            if entity.entity_type in ["player", "ship"] and entity.active:
                valid_targets.append(entity_data)
                
        if not valid_targets:
            agent.target = None
            return False  # No targets found
            
        # Sort by distance
        valid_targets.sort(key=lambda x: x["distance"])
        
        # Set the nearest as target
        agent.target = valid_targets[0]["entity"]
        return True


class PursueTargetNode(BehaviorNode):
    """Move toward the current target."""
    
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Move toward the target if one exists."""
        if not agent.target or not agent.entity:
            return False
            
        # Calculate direction to target
        ship = agent.entity
        target_pos = agent.target.position
        ship_pos = ship.position
        
        # Calculate direction vector
        dx = target_pos[0] - ship_pos[0]
        dy = target_pos[1] - ship_pos[1]
        distance = math.sqrt(dx*dx + dy*dy)
        
        if distance < 10.0:  # Already close enough
            return True
            
        # Calculate desired heading in degrees
        desired_heading = math.degrees(math.atan2(dx, dy)) % 360
        
        # Adjust ship heading toward desired heading
        current_heading = ship.heading
        heading_diff = (desired_heading - current_heading + 180) % 360 - 180
        
        # Turn toward target
        turn_speed = 90.0 * delta_time  # degrees per second
        if abs(heading_diff) > turn_speed:
            if heading_diff > 0:
                ship.heading = (current_heading + turn_speed) % 360
            else:
                ship.heading = (current_heading - turn_speed) % 360
        else:
            ship.heading = desired_heading
            
        # Accelerate if pointing approximately at target
        if abs(heading_diff) < 30:
            thrust = 50.0 * agent.difficulty  # Higher difficulty = more thrust
            ship.accelerate(thrust, delta_time)
            
        return True


class AttackTargetNode(BehaviorNode):
    """Attack the current target if in range and weapons are ready."""
    
    def execute(self, agent: AIAgent, game_state, delta_time: float) -> bool:
        """Attack the target if conditions are met."""
        if not agent.target or not agent.entity:
            return False
            
        ship = agent.entity
        target = agent.target
        
        # Check if we have weapons
        weapons = ship.components.get("weapon", [])
        if not weapons:
            return False
            
        # Find a ready weapon
        ready_weapon = None
        for weapon in weapons:
            if weapon.is_ready():
                ready_weapon = weapon
                break
                
        if not ready_weapon:
            return False  # No ready weapons
            
        # Check if target is in range and arc
        target_pos = target.position
        ship_pos = ship.position
        
        # Calculate distance and bearing to target
        dx = target_pos[0] - ship_pos[0]
        dy = target_pos[1] - ship_pos[1]
        distance = math.sqrt(dx*dx + dy*dy)
        target_bearing = math.degrees(math.atan2(dx, dy)) % 360
        
        # Check if in weapon range
        if distance > ready_weapon.range:
            return False  # Target out of range
            
        # Check if target is in firing arc (relative to ship heading)
        rel_bearing = (target_bearing - ship.heading + 180) % 360 - 180
        if abs(rel_bearing) > ready_weapon.arc / 2:
            return False  # Target outside firing arc
            
        # Fire the weapon
        success, damage = ready_weapon.fire(target)
        if success:
            agent.knowledge_base["last_attack"] = {
                "target": target,
                "weapon": ready_weapon,
                "damage": damage,
                "time": time.time()
            }
            
        return success


## CONVERTER SYSTEM (#converter_system)

The Converter System manages resource transformation processes including smelting, refining, and crafting. It provides a flexible framework for creating resource converters and recipes, along with efficient management of conversion processes.

### Core Components

```python
# Key enums for converter types and tiers
class ConverterType(Enum):
    """Types of resource converters."""
    SMELTER = auto()    # Converts raw ores to metals
    REFINERY = auto()   # Refines raw materials
    FABRICATOR = auto() # Creates components from materials
    ASSEMBLER = auto()  # Assembles complex items
    BIOREACTOR = auto() # Processes organic materials

class ConverterTier(Enum):
    """Quality tiers for converters."""
    BASIC = 1      # Basic functionality, low efficiency
    STANDARD = 2   # Standard functionality, moderate efficiency
    ADVANCED = 3   # Advanced functionality, high efficiency
    SUPERIOR = 4   # Superior functionality, very high efficiency
    PROTOTYPE = 5  # Experimental functionality, exceptional efficiency

# Core data structures
class ResourceType(Enum):
    """Types of resources that can be converted."""
    RAW_ORE = auto()
    PROCESSED_METAL = auto()
    COMPONENT = auto()
    BIOLOGICAL = auto()
    SYNTHETIC = auto()
    ENERGY = auto()
```

### Recipe System

```python
class Recipe:
    """Represents a conversion recipe with inputs, outputs, and processing details."""
    
    def __init__(
        self,
        recipe_id: str,
        name: str,
        input_resources: Dict[str, int],
        output_resources: Dict[str, int],
        processing_time: float,
        energy_cost: float,
        compatible_types: List[ConverterType] = None,
        min_tier: ConverterTier = ConverterTier.BASIC,
    ):
        """Initialize a recipe."""
        self.id = recipe_id
        self.name = name
        self.input_resources = input_resources  # resource_id: amount
        self.output_resources = output_resources  # resource_id: amount
        self.processing_time = processing_time  # in seconds
        self.energy_cost = energy_cost  # energy units required
        self.compatible_types = compatible_types or list(ConverterType)
        self.min_tier = min_tier
        
    def is_compatible_with(self, converter: 'Converter') -> bool:
        """Check if this recipe is compatible with a given converter."""
        return (
            converter.type in self.compatible_types
            and converter.tier.value >= self.min_tier.value
        )
```

### Converter Implementation

```python
class Converter:
    """Represents a resource converter that can process recipes."""
    
    def __init__(
        self,
        converter_id: str,
        name: str,
        converter_type: ConverterType,
        tier: ConverterTier = ConverterTier.BASIC,
        efficiency: float = 1.0,
        max_queue_size: int = 3,
    ):
        """Initialize a converter."""
        self.id = converter_id
        self.name = name
        self.type = converter_type
        self.tier = tier
        self.base_efficiency = efficiency
        self.max_queue_size = max_queue_size
        self.active_processes = []  # List of active conversion processes
        self.modifiers = {}  # Dict of modifier name: modifier value
        
    def calculate_efficiency(self) -> float:
        """Calculate the overall efficiency based on tier and modifiers."""
        # Base efficiency is affected by tier and custom modifiers
        tier_bonus = 0.1 * (self.tier.value - 1)  # Each tier adds 10% efficiency
        total_modifiers = sum(self.modifiers.values())
        return self.base_efficiency * (1 + tier_bonus + total_modifiers)
    
    def can_process(self, recipe: Recipe) -> bool:
        """Check if this converter can process a recipe."""
        return (
            recipe.is_compatible_with(self)
            and len(self.active_processes) < self.max_queue_size
        )
```

### Converter Registry

```python
class ConverterRegistry:
    """Central registry for converters and recipes."""
    
    def __init__(self):
        """Initialize an empty registry."""
        self.converters = {}  # converter_id: Converter
        self.recipes = {}  # recipe_id: Recipe
        
    def register_converter(self, converter: Converter) -> None:
        """Register a converter in the registry."""
        self.converters[converter.id] = converter
        
    def register_recipe(self, recipe: Recipe) -> None:
        """Register a recipe in the registry."""
        self.recipes[recipe.id] = recipe
        
    def get_converter(self, converter_id: str) -> Optional[Converter]:
        """Get a converter by ID."""
        return self.converters.get(converter_id)
        
    def get_recipe(self, recipe_id: str) -> Optional[Recipe]:
        """Get a recipe by ID."""
        return self.recipes.get(recipe_id)
        
    def get_compatible_recipes(self, converter: Converter) -> List[Recipe]:
        """Get all recipes compatible with a given converter."""
        return [recipe for recipe in self.recipes.values() 
                if recipe.is_compatible_with(converter)]
                
    def get_converters_for_recipe(self, recipe: Recipe) -> List[Converter]:
        """Get all converters compatible with a given recipe."""
        return [converter for converter in self.converters.values() 
                if recipe.is_compatible_with(converter)]
```

### Production Chains

```python
def create_production_chain(self, final_recipe_id: str) -> Dict[str, List[str]]:
    """Create a production chain for a target recipe.
    
    Maps out all the intermediate recipes needed to produce the inputs for the target recipe.
    
    Args:
        final_recipe_id: The ID of the final recipe to produce
        
    Returns:
        A dictionary mapping recipe IDs to lists of prerequisite recipe IDs
    """
    if final_recipe_id not in self.recipes:
        return {}
        
    production_chain = {}
    self._build_production_chain(final_recipe_id, production_chain, set())
    return production_chain
```


## ANIMATION SYSTEM (#animation_system)

The Animation System provides a framework for creating and managing UI animations, supporting different animation styles and transitions that are tailored to the game's visual themes.

### Animation Style Enums

```python
class AnimationStyle(Enum):
    """Enum for animation styles."""
    NONE = auto()      # No animation
    FADE_IN = auto()   # Fade in from transparent
    FADE_OUT = auto()  # Fade out to transparent
    SLIDE_IN = auto()  # Slide in from edge
    SLIDE_OUT = auto() # Slide out to edge
    PULSE = auto()     # Pulsing animation
    BLINK = auto()     # Blinking animation

    @classmethod
    def get_animation_style(cls, ui_style: UIStyle) -> "AnimationStyle":
        """Get the appropriate animation style for a UI style."""
        try:
            if ui_style == UIStyle.SYMBIOTIC:
                return AnimationStyle.FADE_IN
            elif ui_style == UIStyle.ASTEROID:
                return AnimationStyle.SLIDE_IN
            elif ui_style == UIStyle.MECHANICAL:
                return AnimationStyle.NONE
            elif ui_style == UIStyle.QUANTUM:
                return AnimationStyle.PULSE
            elif ui_style == UIStyle.FLEET:
                return AnimationStyle.SLIDE_IN
            else:
                return AnimationStyle.NONE
        except Exception as e:
            logging.error(f"Error getting animation style: {e}")
            return AnimationStyle.NONE
```

### Advanced Animation Styles

```python
# Extended animation types from animation_helper.py
CELLULAR = auto()     # Cell-by-cell reveal mimicking Game of Life
FRACTAL = auto()      # Recursive splitting pattern
WARP = auto()         # Space-warp style transitions
QUANTUM_FLUX = auto() # Probability wave collapse
MINERAL_GROWTH = auto() # Crystal-like growth patterns

class AnimationStyle(Enum):
    """Animation styles for transitions"""

    @classmethod
    def get_animation_for_style(cls, ui_style: UIStyle) -> "AnimationStyle":
        """Get appropriate animation style based on UI style

        Args:
            ui_style: UI style to get animation style for

        Returns:
            AnimationStyle appropriate for the UI style
        """
        try:
            animation_map = {
                UIStyle.SYMBIOTIC: cls.CELLULAR,
                UIStyle.ASTEROID: cls.MINERAL_GROWTH,
                UIStyle.MECHANICAL: cls.FRACTAL,
                UIStyle.QUANTUM: cls.QUANTUM_FLUX,
                UIStyle.FLEET: cls.WARP,
            }
            return animation_map.get(ui_style, cls.CELLULAR)
        except Exception as e:
            logging.error(f"Error getting animation for style: {e}")
            return cls.CELLULAR
```

### Animation Implementation in UIElement

```python
# Animation state within UIElement
self.animation = {
    "active": False,
    "style": AnimationStyle.NONE,
    "progress": 0.0,
    "duration": 0.0,
    "start_time": 0.0,
}

def start_animation(self, duration: float = 0.5) -> None:
    """Start an animation sequence."""
    try:
        # Get animation style based on UI style
        animation_style = AnimationStyle.get_animation_style(self.style)

        # Set animation state
        self.animation = {
            "active": True,
            "style": animation_style,
            "progress": 0.0,
            "duration": duration,
            "start_time": time.time(),
        }
    except Exception as e:
        logging.error(f"Error starting animation: {e}")

def update_animation(self, delta_time: float = 0.0) -> bool:
    """Update animation state based on elapsed time."""
    try:
        return self._process_animation_progress(delta_time)
    except Exception as e:
        logging.error(f"Error updating animation: {e}")
        self.animation["active"] = False
        return False
```

### Animation Effects Implementation

```python
def _apply_animation_effect(self, color: Tuple[int, int, int]) -> Tuple[int, int, int]:
    """Apply animation effect to a color based on current animation state."""
    try:
        if not self.animation["active"]:
            return color

        r, g, b = color
        progress = self.animation["progress"]

        if self.animation["style"] == AnimationStyle.FADE_IN:
            # Fade in: increase alpha from 0 to 1
            factor = progress
            return (int(r * factor), int(g * factor), int(b * factor))

        elif self.animation["style"] == AnimationStyle.FADE_OUT:
            # Fade out: decrease alpha from 1 to 0
            factor = 1.0 - progress
            return (int(r * factor), int(g * factor), int(b * factor))

        elif self.animation["style"] == AnimationStyle.PULSE:
            # Pulse: oscillate brightness
            factor = 0.7 + 0.3 * math.sin(progress * math.pi * 2)
            return (
                min(255, int(r * factor)),
                min(255, int(g * factor)),
                min(255, int(b * factor)),
            )

        elif self.animation["style"] == AnimationStyle.BLINK:
            # Blink: on/off based on progress
            blink_state = (progress * 4) % 1.0 > 0.5
            factor = 1.0 if blink_state else 0.3
            return (int(r * factor), int(g * factor), int(b * factor))

        else:
            return color

    except Exception as e:
        logging.error(f"Error applying animation effect: {e}")
        return color

def _process_animation_progress(self, delta_time):
    if not self.animation["active"]:
        return False

    # Calculate elapsed time
    if delta_time <= 0:
        current_time = time.time()
        elapsed = current_time - self.animation["start_time"]
    else:
        elapsed = delta_time

    # Update progress
    duration = max(0.001, self.animation["duration"])
    self.animation["progress"] = min(1.0, elapsed / duration)

    # Check if animation is complete
    if self.animation["progress"] >= 1.0:
        self.animation["active"] = False
        return False

    return True
```


## SYMBIOTE EVOLUTION SYSTEM (#symbiote_system)

The Symbiote Evolution System forms the core game engine that powers the evolution simulation mechanics. This system uses cellular automaton principles, procedural generation, and evolutionary algorithms to model symbiote growth, mutation, and adaptation.

### Core Principles and Mathematical Models

```python
class SymbioteEvolutionAlgorithm:
    """Manages symbiote evolution based on mineral consumption and environmental factors."""

    def __init__(
        self,
        initial_aggression=0.2,
        growth_rate=0.05,
        base_mutation_rate=0.01,
        carrying_capacity=100,
        learning_enabled=True,
    ):
        self.aggression = initial_aggression
        self.growth_rate = growth_rate
        self.base_mutation_rate = base_mutation_rate
        self.carrying_capacity = carrying_capacity
        self.learning_enabled = learning_enabled
        self.evolution_history = []
        self.mineral_consumption = {"common": 0, "rare": 0, "precious": 0, "anomaly": 0}
        # Initialize random number generator with a fixed seed for reproducibility
        self.rng = Generator(PCG64(42))
```

### Cellular Automaton Implementation

The system uses cellular automaton principles (based on Conway's Game of Life) but with modified rules to simulate symbiote colony growth and development:

```python
def generate_cellular_automaton_rules(self, hunger, genome):
    """Generate cellular automaton rules for symbiote growth."""
    # Default rule sets
    birth_set = {3}
    survival_set = {2, 3}

    # Adjust based on hunger and genome
    if hunger > 0.7:
        # Hungry symbiotes are more aggressive in growth
        birth_set.add(2)

    if genome.get("expansion_drive", 1.0) > 1.2:
        # Expansive races grow more easily
        birth_set.add(2)

    if genome.get("intelligence", 0.5) > 0.8:
        # Intelligent races are more strategic about survival
        survival_set.add(4)

    return birth_set, survival_set

def update_cellular_automaton(self, grid, birth_set, survival_set):
    """Update grid using cellular automaton rules."""
    if not SCIPY_AVAILABLE:
        # Fallback implementation when scipy is not available
        return self._update_cellular_automaton_manual(grid, birth_set, survival_set)

    # Use scipy for faster implementation when available
    # Count neighbors
    neighbors_kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
    neighbor_count = ndimage.convolve(
        grid.astype(np.int8), neighbors_kernel, mode="constant", cval=0
    )

    # Create new grid
    new_grid = np.zeros_like(grid)

    # Apply survival rules
    for n in survival_set:
        new_grid |= (neighbor_count == n) & grid

    # Apply birth rules
    for n in birth_set:
        new_grid |= (neighbor_count == n) & (~grid)

    return new_grid
```

### Mineral Consumption and Evolution

Symbiote evolution is driven by mineral consumption, which affects mutation rates and behavioral characteristics:

```python
def process_mineral_feeding(self, minerals, population, aggression):
    """Process minerals through the evolution algorithm and return new population and aggression values,
    along with any mutations."""
    # Track mineral consumption
    for mineral_type, amount in minerals.items():
        self.mineral_consumption[mineral_type] += amount

    # Calculate total mineral value
    total_value = (
        minerals.get("common", 0)
        + minerals.get("rare", 0) * 3
        + minerals.get("precious", 0) * 5
        + minerals.get("anomaly", 0) * 10
    )

    # Calculate population change based on mineral consumption
    population_boost = total_value * 0.1
    new_population = population + population_boost

    # Adjust aggression based on mineral types
    # Rare minerals reduce aggression, anomalies increase it
    aggression_change = 0
    if minerals.get("rare", 0) > 0:
        aggression_change -= 0.01 * minerals["rare"]
    if minerals.get("anomaly", 0) > 0:
        aggression_change += 0.02 * minerals["anomaly"]

    new_aggression = max(0.1, min(0.9, aggression + aggression_change))

    # Generate mutations based on mineral consumption
    mutations = self._generate_mutations(minerals)

    return new_population, new_aggression, mutations
```

### Mutation Generation and Adaptation

```python
def _generate_mutations(self, minerals):
    """Generate mutations based on minerals consumed."""
    mutations = []

    # Mutation chance increases with rare and anomalous minerals
    mutation_chance = (
        self.base_mutation_rate
        + minerals.get("rare", 0) * 0.01
        + minerals.get("precious", 0) * 0.02
        + minerals.get("anomaly", 0) * 0.05
    )

    # Potential attributes that could mutate
    attributes = [
        "metabolism_rate",
        "expansion_drive",
        "mutation_rate",
        "intelligence",
        "aggression_base",
    ]

    # Generate random mutations
    for attr in attributes:
        if self.rng.random() < mutation_chance:
            # Determine mutation magnitude
            magnitude = self.rng.normal(1.0, 0.1)  # Mean 1.0, std dev 0.1

            # Determine mutation type based on magnitude
            mutation_type = "standard"
            if magnitude > 1.1:
                mutation_type = "beneficial"
            elif magnitude > 1.05:
                mutation_type = "significant"
            elif magnitude < 0.9:
                mutation_type = "negative"

            mutations.append(
                {"attribute": attr, "magnitude": magnitude, "type": mutation_type}
            )

    return mutations
```

### Colony Identification and Interaction

The system identifies distinct colonies and models their interactions:

```python
def identify_colonies(self, grid) -> Tuple[np.ndarray, int]:
    """Identify distinct colonies in the grid.

    Args:
        grid: Binary grid representing symbiote presence

    Returns:
        tuple: (labeled_grid, num_colonies) where labeled_grid is a numpy array
              with the same shape as grid, and num_colonies is the number of colonies found.
    """
    if not SCIPY_AVAILABLE:
        # Fallback implementation when scipy is not available
        return self._manual_label_grid(grid)
    # Use cast to tell type checker that ndimage.label returns a tuple of (ndarray, int)
    label_result = cast(Tuple[np.ndarray, int], ndimage.label(grid))
    return label_result[0], label_result[1]

def simulate_colony_interaction(self, grid, genome, aggression):
    """Simulate interaction between different colonies of the same race."""
    # Identify colonies
    labeled_grid, num_colonies = self.identify_colonies(grid)

    if num_colonies <= 1:
        return grid

    # For multiple colonies, simulate interaction based on aggression
    competition_factor = min(1.0, aggression * 2)

    # Colonies compete or cooperate based on aggression
    if competition_factor > 0.7:
        return self._handle_colony_competition(grid, labeled_grid, num_colonies)
    else:
        return self._handle_colony_cooperation(grid, labeled_grid, num_colonies)
```

### Environmental Interaction

```python
def apply_environmental_effects(self, grid, mineral_map, hostility):
    """Apply environmental effects to the grid based on mineral distribution."""
    return grid & (
        self.rng.random(grid.shape) < (1 - hostility + mineral_map * 0.5)
    )

def calculate_expansion_index(self, current_grid, previous_grid):
    """Calculate how much a race is expanding."""
    if previous_grid is None:
        return 0

    current_count = np.sum(current_grid)
    previous_count = np.sum(previous_grid)

    if previous_count == 0:
        return 1.0 if current_count > 0 else 0.0

    return (current_count - previous_count) / previous_count
```

### Advanced Population Models

The system includes sophisticated population modeling approaches for more realistic ecological dynamics and species interactions:

```python
class MultiSpeciesPopulation:
    """Implements a multi-species population model using an extended Lotka–Volterra approach.
    Each species i has:
      - A logistic growth baseline: dN_i/dt = r_i * N_i * (1 - N_i/K_i)
      - Interaction terms for every other species j, scaled by interaction[i][j].
        * Positive values => i preys on j or benefits from j
        * Negative values => i competes with j
    """

    def __init__(
        self,
        species_count: int,
        base_growth_rates: List[float],
        carrying_caps: List[float],
        interaction_matrix: List[List[float]],
    ):
        """Initialize the multi-species population model.
        
        Args:
            species_count: Number of species tracked (including symbiote variants, players, etc.).
            base_growth_rates: Growth rate r_i for each species i (length = species_count).
            carrying_caps: Carrying capacity K_i for each species i (length = species_count).
            interaction_matrix: A 2D matrix describing pairwise interactions.
        """
        self.species_count = species_count
        self.rates = base_growth_rates
        self.caps = carrying_caps
        self.interaction_matrix = interaction_matrix

    def multi_species_step(self, populations: List[float], dt: float = 1.0) -> List[float]:
        """Advance each species by one step, returning new population levels.
        
        Equation used:
            dN_i/dt = r_i*N_i * (1 - (N_i / K_i)) + sum_{j != i}( interaction[i][j] * N_i * N_j )
        """
        new_pops = populations.copy()
        for i in range(self.species_count):
            # Implement Lotka-Volterra dynamics with competition/predation
            # This simulates realistic ecological interactions between species
            pass
        return new_pops


class DelayedGrowthPopulation:
    """Introduces a delay into population growth by referencing previous states
    from a fixed number of steps ago. This approximates certain delay differential
    equations, commonly used when a population's reproductive output depends on
    conditions from earlier periods (gestation, resource acquisition lags, etc.).
    """

    def __init__(self, delay_steps: int, base_growth_rate: float, max_capacity: float):
        """Initialize delayed growth population model.
        
        Args:
            delay_steps: How many turns behind the current population influences next growth.
            base_growth_rate: Growth rate factor (like r in logistic equations).
            max_capacity: Optional carrying capacity for capping population.
        """
        self.delay_steps = max(1, delay_steps)
        self.base_growth_rate = base_growth_rate
        self.max_capacity = max_capacity
        self.history = []

    def record_population(self, current_pop: float) -> None:
        """Record the current population for future reference."""
        self.history.append(current_pop)

    def update_population(self, current_pop: float) -> float:
        """Update population using values from delay_steps ago."""
        # This creates realistic boom-bust cycles and lag effects in populations
        # Important for modeling complex symbiote behaviors
        return max(0.0, min(current_pop + growth, self.max_capacity))


class StageStructuredPopulation:
    """Splits population into multiple life stages, each with different
    transition, mortality, or reproduction rates. For example:
      - Egg -> Larva -> Adult -> Boss
    At each update, a fraction of individuals in each stage transition
    to the next stage, possibly with unique growth or mortality.
    """

    def __init__(
        self,
        stages: List[str],
        transitions: Dict[str, float],
        stage_mortality: Dict[str, float] = None,
        stage_growth: Dict[str, float] = None,
    ):
        """Initialize stage-structured population model.
        
        Args:
            stages: Ordered list of stage names (e.g., ["egg", "juvenile", "adult"]).
            transitions: Fraction of each stage that moves to the next stage per update.
            stage_mortality: Optional dict mapping each stage to a mortality fraction.
            stage_growth: Optional dict mapping each stage to an extra birth factor.
        """
        self.stages = stages
        self.transitions = transitions
        self.stage_mortality = stage_mortality if stage_mortality else {}
        self.stage_growth = stage_growth if stage_growth else {}

    def update_stages(self, stage_pops: Dict[str, float]) -> Dict[str, float]:
        """Update stage populations through mortality, growth, and transitions."""
        new_stage_pops = {st: 0.0 for st in self.stages}
        
        # Apply complex life stage transitions with distinct properties per life stage
        # This creates realistic population structures and evolutionary patterns
        
        return new_stage_pops
```

## ASTEROID FIELD SYSTEM (#asteroid_system)

The Asteroid Field System is responsible for procedurally generating, managing, and visualizing asteroid fields in the game. This system employs various noise algorithms, pattern generators, and cellular automaton simulations to create dynamic, realistic asteroid distributions with resource values.

### Core Structure and Components

```python
class AsteroidField:
    """Represents a field of asteroids on a grid.
    Uses NumPy for performance and supports complex cellular automaton rules."""

    def __init__(self, width: int = GRID_WIDTH, height: int = GRID_HEIGHT, seed: int = None) -> None:
        """Initialize a new asteroid field with the specified dimensions."""
        self.width = width
        self.height = height

        # NumPy arrays for better performance
        # 0 = empty, 1-100 = asteroid value
        self.grid = np.zeros((height, width), dtype=np.int16)

        # Rare status: 0 = normal, 1 = rare
        self.rare_grid = np.zeros((height, width), dtype=np.int8)

        # Energy levels for each cell (affects growth and stability)
        self.energy_grid = np.zeros((height, width), dtype=np.float32)

        # Entity grid (0 = empty, 1,2,3 = race ID)
        self.entity_grid = np.zeros((height, width), dtype=np.int8)

        # Specialized grids for each race's influence
        self.influence_grids = {}

        # Cellular automata parameters (default: similar to Conway's Game of Life)
        self.birth_set: Set[int] = {3}
        self.survival_set: Set[int] = {2, 3}
        self.energy_decay = 0.02  # Energy decay rate
        self.energy_spread = 0.1  # How much energy spreads to neighbors
        self.apply_edge_wrapping = True  # Whether to wrap around the grid edges

        # Asteroid parameters
        self.regen_rate: float = 0.01
        self.rare_chance: float = 0.1
        self.rare_bonus_multiplier: float = 3.0
        self.anomaly_chance: float = 0.01  # Chance for anomalous minerals
```

### Procedural Generation with Patterns

The Asteroid Field System supports multiple generation patterns through the AsteroidGenerator class:

```python
class AsteroidGenerator(BaseGenerator):
    """Generator for procedural asteroid fields with multiple layers and patterns.
    Inherits from BaseGenerator to leverage common generation functionality."""

    def __init__(self, entity_id: Optional[str] = None, seed: Optional[int] = None,
                 width: int = 100, height: int = 100, 
                 color: Tuple[int, int, int] = (150, 150, 100),
                 position: Optional[Tuple[int, int]] = None,
                 noise_generator: Optional[NoiseGenerator] = None) -> None:
        """Initialize the asteroid generator."""
        # Pattern types
        self.pattern_types = ["spiral", "ring", "gradient", "void"]

    def generate_field(self, pattern_weights: Optional[List[float]] = None) -> Tuple[np.ndarray, Dict[str, Any]]:
        """Generate a complete asteroid field with optional pattern weighting."""
        # Apply base noise layer
        noise_grid = self._generate_base_noise()

        # Apply patterns if weights provided
        if pattern_weights and len(pattern_weights) == len(self.pattern_types):
            # Generate patterns based on pattern types
            patterns = []
            for pattern_type in self.pattern_types:
                if pattern_type == "spiral":
                    patterns.append(self._spiral_pattern())
                elif pattern_type == "ring":
                    patterns.append(self._ring_pattern())
                elif pattern_type == "gradient":
                    patterns.append(self._gradient_pattern())
                elif pattern_type == "void":
                    patterns.append(self._void_pattern())

            # Apply weighted patterns
            pattern_grid = apply_weighted_patterns(
                patterns, pattern_weights, self.height, self.width
            )

            # Blend noise and patterns based on pattern_strength
            pattern_strength = self.get_parameter("pattern_strength", 0.4)
            grid = noise_grid * (1 - pattern_strength) + pattern_grid * pattern_strength
```

### Specialized Asteroid Formation Patterns

```python
def generate_asteroid_belt(
    self, center_distance=0.5, belt_width=0.2, density=0.7, noise_scale=0.1
):
    """Generate an asteroid belt pattern around a center point."""
    # Calculate center coordinates
    center_y, center_x = self.height // 2, self.width // 2

    # Generate ring pattern
    ring_grid = generate_ring_pattern(
        self.width,
        self.height,
        center=(center_x, center_y),
        num_rings=int(1 / belt_width),
        falloff=1 - center_distance,
    )

    # Apply noise to make the belt more natural
    noise_grid = self._generate_base_noise(scale=noise_scale)

    # Combine ring pattern with noise
    combined_grid = ring_grid * 0.7 + noise_grid * 0.3

    # Apply threshold based on density
    asteroid_grid = (combined_grid > (1 - density)).astype(int)

    # Apply cellular automaton to smooth the field
    return self._apply_cellular_automaton(asteroid_grid)

def generate_asteroid_cluster(
    self, num_clusters=3, cluster_size=10, density=0.7, noise_scale=0.1
):
    """Generate asteroid clusters at random locations."""
    # Create empty grid
    grid = np.zeros((self.height, self.width))

    # Generate base noise
    noise_grid = self._generate_base_noise(scale=noise_scale)

    # Create random cluster centers
    rng = np.random.default_rng(self.seed)
    centers = []
    for _ in range(num_clusters):
        x = rng.integers(0, self.width)
        y = rng.integers(0, self.height)
        centers.append((x, y))

    # Create clusters around centers
    for center_x, center_y in centers:
        # Calculate direction from center to point
        direction = math.atan2(
            center_y - self.height / 2, center_x - self.width / 2
        )
        cluster_grid = generate_gradient_pattern(
            self.width,
            self.height,
            direction=direction,
            steepness=cluster_size / 10,
        )

        # Add to the main grid
        grid = np.maximum(grid, cluster_grid)

    # Combine with noise and apply threshold
    combined_grid = grid * 0.7 + noise_grid * 0.3
    asteroid_grid = (combined_grid > (1 - density)).astype(int)

    # Apply cellular automaton to smooth the field
    return self._apply_cellular_automaton(asteroid_grid)
```

### Resource Distribution and Cellular Automaton Evolution

```python
def update_cellular_automaton(self, iterations: int = 1) -> None:
    """Update the asteroid field using cellular automaton rules."""
    for _ in range(iterations):
        # Count neighbors using convolution for performance
        if SCIPY_AVAILABLE:
            # Use scipy for optimized convolution
            neighbors_kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
            neighbor_count = ndimage.convolve(
                self.grid > 0, neighbors_kernel, mode="wrap" if self.apply_edge_wrapping else "constant"
            )
        else:
            # Manual fallback implementation
            neighbor_count = np.zeros_like(self.grid)
            h, w = self.grid.shape
            for y in range(h):
                for x in range(w):
                    # Count neighbors with wrapping if enabled
                    neighbors = 0
                    for dy in [-1, 0, 1]:
                        for dx in [-1, 0, 1]:
                            if dx == 0 and dy == 0:
                                continue
                            nx, ny = x + dx, y + dy
                            if self.apply_edge_wrapping:
                                nx %= w
                                ny %= h
                            if 0 <= nx < w and 0 <= ny < h and self.grid[ny, nx] > 0:
                                neighbors += 1
                    neighbor_count[y, x] = neighbors

        # Apply cellular automaton rules
        new_grid = np.zeros_like(self.grid)
        # Apply birth and survival rules
        for n in self.birth_set:
            mask = (neighbor_count == n) & (self.grid == 0)
            new_grid[mask] = 1
        for n in self.survival_set:
            mask = (neighbor_count == n) & (self.grid > 0)
            new_grid[mask] = self.grid[mask]

        # Update energy distribution based on new grid
        # Energy flows from high concentration to low concentration
        if SCIPY_AVAILABLE:
            # Use gaussian filter for energy diffusion
            self.energy_grid = ndimage.gaussian_filter(self.energy_grid, sigma=1) * (1 - self.energy_decay)
        else:
            # Manual energy diffusion implementation
            energy_diffusion = np.zeros_like(self.energy_grid)
            for y in range(self.height):
                for x in range(self.width):
                    total_energy = 0
                    count = 0
                    for dy in [-1, 0, 1]:
                        for dx in [-1, 0, 1]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < self.width and 0 <= ny < self.height:
                                total_energy += self.energy_grid[ny, nx]
                                count += 1
                    if count > 0:
                        energy_diffusion[y, x] = total_energy / count
            # Apply diffusion with decay
            self.energy_grid = energy_diffusion * (1 - self.energy_decay)

        # Update the grid
        self.grid = new_grid
```

### Asteroid Field Visualization

```python
class AsteroidFieldVisualizer(UIElement):
    """Cellular automaton-based asteroid field visualizer"""

    def __init__(self, x: int, y: int, width: int, height: int,
                density: float = 0.3, style: UIStyle = UIStyle.ASTEROID):


## MINING SYSTEM (#mining_system)

The Mining System handles the creation, evolution, and management of symbiotic mining races that extract resources from asteroid fields. These races have unique traits, behaviors, and evolutionary patterns influenced by their environment and resource availability.

### Core Structure and Components

```python
class MinerEntity(BaseEntity):
    """Represents a symbiotic mining race that evolves in the asteroid field.
    
    These entities interact with asteroid fields, develop territories, process minerals,
    and evolve through a cellular automaton system with unique genetic traits.
    """

    def __init__(self, race_id: int, color: Optional[Tuple[int, int, int]] = None,
                 position: Optional[Tuple[int, int]] = None,
                 trait: str = None,
                 cellular_automaton_algorithm: Optional[Any] = None) -> None:
        """Initialize a new mining race.
        
        Args:
            race_id: Unique identifier for the race
            color: RGB color tuple for visual representation
            position: Optional starting position
            trait: Race trait determining specialization ("adaptive", "expansive", "selective")
            cellular_automaton_algorithm: Algorithm for evolution simulation
        """
        super().__init__(entity_id=str(race_id), entity_type="miner", color=color, position=position)
        
        # Core attributes
        self.race_id = race_id
        self.trait = trait or random.choice(["adaptive", "expansive", "selective"])
        self.aggression = 0.2  # Default aggression level (0-1)
        self.hunger = 0.0  # Hunger level (0-1)
        self.mining_efficiency = 0.5  # Base mining efficiency
        self.hunger_rate = 0.05  # Rate at which hunger increases per turn
        self.initial_density = 0.05  # Initial population density
        self.population = 0  # Current population count
        
        # Cellular automaton rules
        self.birth_set = {3}  # Default birth rule (similar to Conway's Game of Life)
        self.survival_set = {2, 3}  # Default survival rule
        
        # Specialized resources and territory
        self.mineral_consumption = defaultdict(int)  # Tracks mineral consumption by type
        self.resource_affinity = {}  # Preferred resources based on trait
        self.territory_center = None  # Center of territory
        self.territory_radius = 0  # Approximate territory radius
        self.territory_density = 0.0  # Population density in territory
        self.field = None  # Reference to the asteroid field
        
        # Genome and evolution
        self.genome = self._initialize_genome_by_trait()  # Genetic traits
        self.fed_this_turn = False  # Tracking feeding for evolution
        
        # Setup evolution algorithm
        self.evolution_algorithm = cellular_automaton_algorithm or SymbioteEvolutionAlgorithm()
```

### Genome Initialization Based on Traits

Each mining race has a unique genetic makeup influenced by their trait:

```python
def _initialize_genome_by_trait(self) -> Dict[str, float]:
    """Initialize the genome based on the race's trait.
    
    Returns:
        Dictionary of genome attributes with values modified by the race's trait
    """
    # Base genome values
    genome = {
        "metabolism_rate": 1.0,
        "mutation_rate": 0.01,
        "intelligence": 0.5,
        "expansion_drive": 1.0,
        "adaptation_speed": 0.5,
        "resource_efficiency": 0.7,
        "aggression_base": 0.2,
    }
    
    # Modify genome based on trait
    if self.trait == "adaptive":
        genome["adaptation_speed"] = 0.8
        genome["mutation_rate"] = 0.02
        genome["metabolism_rate"] = 1.1
        genome["resource_efficiency"] = 0.8
        
    elif self.trait == "expansive":
        genome["expansion_drive"] = 1.4
        genome["metabolism_rate"] = 0.9
        genome["aggression_base"] = 0.3
        
    elif self.trait == "selective":
        genome["intelligence"] = 0.7
        genome["metabolism_rate"] = 1.1
        genome["expansion_drive"] = 0.9
        genome["aggression_base"] = 0.2
        
    return genome
```

### Population Distribution Patterns

Mining races populate asteroid fields using distinct settlement patterns based on their traits:

```python
def populate(self, field: AsteroidField) -> None:
    """Populate the field with this race's symbiotes using unique patterns based on traits.
    
    Args:
        field: The asteroid field to populate
    """
    # Store field as instance variable
    self.field = field
    
    # Each race has a distinct settlement pattern
    try:
        if self.trait == "adaptive":  # Settle in organic, noise-based clusters
            self._populate_adaptive_race(field)
        elif self.trait == "expansive":  # Settle in networks/paths
            self._generate_random_nodes(field)
        else:  # "selective" - Settle near resource-rich areas
            self._populate_selective_race(field)
    except Exception as e:
        logging.error(f"Error in populate method: {str(e)}")
        log_exception(e)
```

### Resource Processing and Mining Efficiency

```python
def process_minerals(self, minerals: Dict[str, int]) -> None:
    """Process minerals for evolution and hunger reduction.
    
    Args:
        minerals: Dictionary of mineral types and amounts extracted
    """
    if not minerals:
        return
    
    # Track mineral consumption
    for mineral_type, amount in minerals.items():
        self.mineral_consumption[mineral_type] += amount
    
    # Use the evolution algorithm
    new_population, new_aggression, mutations = self.evolution_algorithm.process_mineral_feeding(
        self.race_id, minerals, self.population, self.aggression
    )
    
    # Apply results
    self.population = int(new_population)
    self.aggression = new_aggression
    
    # Apply any mutations to the genome
    self.apply_mutations(mutations)
    
    # Mark as fed this turn
    self.fed_this_turn = True

def update_hunger(self, income: int) -> float:
    """Update hunger based on income and return updated aggression level.
    
    Args:
        income: Amount of resources gained
        
    Returns:
        Updated aggression level
    """
    if income > 0:
        # Income reduces hunger
        hunger_reduction = min(self.hunger, 0.2 * (income / 100))
        self.hunger = max(0.0, self.hunger - hunger_reduction)
        self.fed_this_turn = True
    else:
        # Hunger increases each turn without food
        self.hunger = min(1.0, self.hunger + self.hunger_rate)
        self.fed_this_turn = False
    
    # Adjust aggression based on hunger
    self.aggression = max(
        0.1, min(0.9, self.genome["aggression_base"] + self.hunger * 0.5)
    )
    
    return self.aggression
```

### Territory Analysis and Metrics

The mining system uses advanced statistical analysis to track territory metrics:

```python
def analyze_territory(self, field: AsteroidField) -> Dict[str, Any]:
    """Analyze the race's territory and calculate metrics.
    
    Args:
        field: The asteroid field to analyze
        
    Returns:
        Dictionary of territory metrics including center, radius, density, etc.
    """
    # Create a mask for this race
    race_mask = field.entity_grid == self.race_id
    
    if np.sum(race_mask) == 0:
        # Race is extinct
        return {
            "center": None,
            "radius": 0,
            "density": 0,
            "resource_access": 0,
            "fragmentation": 0,
        }
    
    # Find all entity locations
    entity_locations = np.nonzero(race_mask)
    points = np.column_stack(
        (entity_locations[1], entity_locations[0])
    )  # x, y format
    
    # If only a few points, return simple stats
    if len(points) < 5:
        return self._calculate_territory_metrics(points)
        
    # For larger populations, use KMeans to identify colonies
    try:
        # Determine k based on population size
        population = len(points)
        k = min(8, max(1, population // 100))
        
        return self._analyze_territory_clusters(k, points, entity_locations)
    except Exception as e:
        logging.error(f"Error in territory analysis: {e}")
        log_exception(e)
        return {
            "center": None,
            "radius": 0,
            "density": 0,
            "resource_access": 0,
            "fragmentation": 0,
        }
```

### Evolution and Behavior Management

```python
def process_evolution(self, field: AsteroidField) -> None:
    """Process evolution based on environmental factors.
    
    Args:
        field: The asteroid field containing this race
    """
    if self.population < 10:
        return  # Not enough population to evolve
    
    # Analyze territory
    self.analyze_territory(field)
    
    # Get new CA rules from the algorithm
    _, _ = self.evolution_algorithm.generate_cellular_automaton_rules(
        self.race_id, self.hunger, self.genome
    )
    
    # Apply new rules with some chance of mutation
    if random.random() < self.genome["mutation_rate"] * 2:
        possible_rules = [1, 2, 3, 4, 5, 6, 7, 8]
        
        # Birth rules mutation
        if random.random() < 0.3:
            rule = random.choice(possible_rules)
            if rule in self.birth_set:
                self.birth_set.remove(rule)
            else:
                self.birth_set.add(rule)
        
        # Survival rules mutation
        if random.random() < 0.3:
            rule = random.choice(possible_rules)
            if rule in self.survival_set:
                self.survival_set.remove(rule)
            else:
                self.survival_set.add(rule)
    
    # Update behavior based on conditions
    self._update_behavior(field)

def apply_mutations(self, mutations: List[Dict[str, Any]]) -> None:
    """Apply mutations to the genome.
    
    Args:
        mutations: List of mutation dictionaries with attribute and magnitude
    """
    if not mutations:
        return
    
    for mutation in mutations:
        attr = mutation["attribute"]
        magnitude = mutation["magnitude"]
        
        if attr in self.genome:
            old_value = self.genome[attr]
            self.genome[attr] = max(0.1, min(2.0, old_value * magnitude))
            
            # Log significant mutations
            if abs(old_value - self.genome[attr]) > 0.1:
                mutation_type = "increased" if magnitude > 1 else "decreased"
                logging.info(
                    f"Race {self.race_id} {mutation_type} {attr} "
                    f"from {old_value:.2f} to {self.genome[attr]:.2f}"
                )
```

### Mining Status UI Component

```python
class MiningStatus(UIElement):
    """UI component for displaying resource mining operations and statistics."""
    
    def __init__(self, x: int, y: int, width: int, height: int, 
                 bg_color: Tuple[int, int, int] = (30, 30, 30),
                 text_color: Tuple[int, int, int] = (200, 200, 200)) -> None:
        """Initialize the mining status UI element.
        
        Args:
            x, y: Position coordinates
            width, height: Dimensions
            bg_color: Background color
            text_color: Text color
        """
        super().__init__(x, y, width, height)
        self.bg_color = bg_color
        self.text_color = text_color
        self.mineral_data = {}  # Tracks mineral extraction rates
        self.efficiency_data = {}  # Tracks mining efficiency per resource
        self.miner_populations = {}  # Tracks miner race populations
        
    def update_mineral_data(self, mineral_type: str, amount: int) -> None:
        """Update the amount of a specific mineral being extracted.
        
        Args:
            mineral_type: The type of mineral
            amount: The amount being extracted
        """
        self.mineral_data[mineral_type] = amount
        
    def update_efficiency(self, mineral_type: str, efficiency: float) -> None:
        """Update the mining efficiency for a specific mineral.
        
        Args:
            mineral_type: The type of mineral
            efficiency: The mining efficiency (0.0-1.0)
        """
        self.efficiency_data[mineral_type] = efficiency
    
    def update_miner_population(self, race_id: int, population: int) -> None:
        """Update the population count for a miner race.
        
        Args:
            race_id: The race identifier
            population: The current population count
        """
        self.miner_populations[race_id] = population
        
    def draw(self, surface: pygame.Surface) -> None:
        """Draw the mining status UI.
        
        Args:
            surface: The pygame surface to draw on
        """
        # Draw background
        pygame.draw.rect(surface, self.bg_color, (self.x, self.y, self.width, self.height))
        
        # Draw mining efficiency meters
        y_offset = 10
        for mineral_type, efficiency in self.efficiency_data.items():
            self._draw_efficiency_meter(surface, mineral_type, efficiency, y_offset)
            y_offset += 20
            
        # Draw extraction rates
        y_offset += 10
        for mineral_type, amount in self.mineral_data.items():
            text = f"{mineral_type}: {amount}/s"
            draw_text(surface, text, self.x + 10, self.y + y_offset, self.text_color)
            y_offset += 15
            
        # Draw miner populations
        y_offset += 10
        for race_id, population in self.miner_populations.items():
            text = f"Race {race_id}: {population} miners"
            draw_text(surface, text, self.x + 10, self.y + y_offset, self.text_color)
            y_offset += 15
```

### Advanced Population Integration with Mining System

The Mining System can leverage the advanced population models to create more realistic ecological dynamics between mining races:

```python
class EnhancedMinerEntity(MinerEntity):
    """Enhanced version of MinerEntity that incorporates advanced population models
    for more realistic ecological dynamics and life-cycle progression."""
    
    def __init__(self, race_id: int, color: Optional[Tuple[int, int, int]] = None, **kwargs):
        """Initialize enhanced miner entity with advanced population models."""
        super().__init__(race_id, color, **kwargs)
        
        # Initialize multi-species population model for interaction with other races
        self.multi_species_model = MultiSpeciesPopulation(
            species_count=4,  # Default max number of races
            base_growth_rates=[0.05 * self.genome["metabolism_rate"]] * 4,
            carrying_caps=[1000, 1000, 1000, 1000],  # Default carrying capacities
            interaction_matrix=self._initialize_interaction_matrix()
        )
        
        # Initialize delayed growth for resource acquisition lag simulation
        self.delayed_growth = DelayedGrowthPopulation(
            delay_steps=3,  # Resource processing takes time
            base_growth_rate=0.05 * self.genome["metabolism_rate"],
            max_capacity=1000
        )
        
        # Initialize life stage progression for miners
        self.stage_population = StageStructuredPopulation(
            stages=["juvenile", "worker", "specialized", "elder"],
            transitions={
                "juvenile": 0.2,  # 20% of juveniles become workers each turn
                "worker": 0.05,  # 5% of workers become specialized each turn
                "specialized": 0.02,  # 2% of specialized become elders each turn
                "elder": 0.0  # Elders do not transition further
            },
            stage_mortality={
                "juvenile": 0.05,  # 5% juvenile mortality
                "worker": 0.02,  # 2% worker mortality
                "specialized": 0.01,  # 1% specialized mortality 
                "elder": 0.1  # 10% elder mortality
            },
            stage_growth={
                "juvenile": 0.0,  # Juveniles don't reproduce
                "worker": 0.2,  # Each worker has 20% chance to produce juvenile
                "specialized": 0.1,  # Specialized have 10% chance
                "elder": 0.05  # Elders have 5% chance
            }
        )
        
        # Initial stage populations
        self.stage_populations = {
            "juvenile": 10,
            "worker": 5,
            "specialized": 0,
            "elder": 0
        }
        
    def _initialize_interaction_matrix(self) -> List[List[float]]:
        """Initialize the species interaction matrix based on race trait.
        
        Returns:
            A 2D matrix defining how species interact with each other.
            Positive values mean beneficial interactions, negative mean competition.
        """
        # Create default matrix (slight competition between all species)
        matrix = [[-0.01 for _ in range(4)] for _ in range(4)]
        
        # Set diagonal to zero (no self-competition in this model)
        for i in range(4):
            matrix[i][i] = 0.0
            
        # Modify based on race trait
        if self.trait == "adaptive":
            # Adaptive races can benefit from others slightly
            for i in range(4):
                if i != self.race_id - 1:  # Not self
                    matrix[self.race_id - 1][i] = 0.02  # Benefit from other species
        
        elif self.trait == "expansive":
            # Expansive races compete more strongly
            for i in range(4):
                if i != self.race_id - 1:  # Not self
                    matrix[self.race_id - 1][i] = -0.03  # Stronger competition
                    matrix[i][self.race_id - 1] = -0.02  # Others compete back
        
        elif self.trait == "selective":
            # Selective races have more specialized interactions
            for i in range(4):
                if i != self.race_id - 1:  # Not self
                    # Random positive or negative interaction
                    matrix[self.race_id - 1][i] = random.uniform(-0.05, 0.05)
        
        return matrix
    
    def update_population(self, field: AsteroidField, all_populations: List[float]) -> None:
        """Update population using advanced models.
        
        Args:
            field: The asteroid field for resource analysis
            all_populations: List of population counts for all races
        """
        # 1. Record current population for delayed growth
        self.delayed_growth.record_population(self.population)
        
        # 2. Process multi-species interactions
        new_populations = self.multi_species_model.multi_species_step(all_populations)
        potential_population = new_populations[self.race_id - 1]
        
        # 3. Apply delayed effect from resource acquisition
        if len(self.delayed_growth.history) > self.delayed_growth.delay_steps:
            potential_population = self.delayed_growth.update_population(potential_population)
        
        # 4. Update life stage distribution
        self.stage_populations = self.stage_population.update_stages(self.stage_populations)
        
        # 5. Calculate total population and apply it
        new_total = sum(self.stage_populations.values())
        self.population = new_total
        
        # 6. Update mining efficiency based on specialized workers
        specialized_ratio = self.stage_populations.get("specialized", 0) / max(1, new_total)
        self.mining_efficiency = 0.5 + (0.3 * specialized_ratio)
        
        # 7. Update hunger based on elder-to-juvenile ratio (higher ratio = more hunger)
        elder_ratio = self.stage_populations.get("elder", 0) / max(1, new_total)
        juvenile_ratio = self.stage_populations.get("juvenile", 0) / max(1, new_total)
        self.hunger += self.hunger_rate * (1 + elder_ratio - juvenile_ratio)
        self.hunger = min(1.0, max(0.0, self.hunger))
```

### Specialized Mining Behavior by Life Stage

```python
def process_minerals_by_stage(self, minerals: Dict[str, int]) -> Dict[str, int]:
    """Process minerals with different efficiencies based on life stages.
    
    Args:
        minerals: Dictionary of mineral types and amounts
        
    Returns:
        Dictionary of consumed minerals by each life stage
    """
    consumption_by_stage = {stage: 0 for stage in self.stage_populations}
    
    # Different life stages process minerals differently
    for mineral_type, amount in minerals.items():
        # Track overall consumption
        self.mineral_consumption[mineral_type] += amount
        
        # Juveniles prefer common minerals
        if mineral_type == "common":
            juvenile_amount = amount * 0.4  # 40% to juveniles
            consumption_by_stage["juvenile"] += juvenile_amount
        
        # Workers are generalists
        worker_amount = amount * 0.3  # 30% to workers
        consumption_by_stage["worker"] += worker_amount
        
        # Specialized miners are efficient with rare and precious
        if mineral_type in ["rare", "precious"]:
            specialized_amount = amount * 0.5  # 50% to specialized
            consumption_by_stage["specialized"] += specialized_amount
        
        # Elders focus on anomalies
        if mineral_type == "anomaly":
            elder_amount = amount * 0.7  # 70% to elders
            consumption_by_stage["elder"] += elder_amount
    
    # Apply consumption effects to each stage
    for stage, consumed in consumption_by_stage.items():
        if stage == "juvenile":
            # Juveniles grow faster with food
            self.stage_population.stage_growth["worker"] *= (1 + consumed * 0.01)
        elif stage == "worker":
            # Workers get more efficient
            self.mining_efficiency += consumed * 0.001
        elif stage == "specialized":
            # Specialized gain evolution points
            self.evolution_points += consumed
        elif stage == "elder":
            # Elders reduce hunger with their wisdom
            self.hunger = max(0, self.hunger - consumed * 0.01)
    
    return consumption_by_stage

        super().__init__(x, y, width, height, style)
        self.density = density
        self.automaton_grid = self._initialize_grid()
        self.generation = 0
        self.asteroid_chars = ["·", "∙", "•", "◦", "○", "◌", "◍", "◎", "●", "@"]

    def _initialize_grid(self) -> List[List[float]]:
        """Initialize the asteroid field grid with random values"""
        grid = []
        for _ in range(self.height - 2):
            row = []
            for _ in range(self.width - 2):
                # Random value representing asteroid density/size
                value = random.random() if random.random() < self.density else 0
                row.append(value)
            grid.append(row)
        return grid

    def update(self, delta_time: float = 0) -> None:
        """Update the asteroid field visualization."""
        # Only update every few frames for performance
        if random.random() < 0.1:  # 10% chance to update each call
            # Create a new grid to store the next generation
            new_grid = [[0 for _ in range(self.width - 2)] for _ in range(self.height - 2)]

            # Apply cellular automaton rules
            for y in range(self.height - 2):
                for x in range(self.width - 2):
                    # Calculate the average of neighboring cells
                    avg = self._calculate_cell_average(x, y)

                    # Apply different rules based on cell state
                    if self.automaton_grid[y][x] > 0:
                        # Cell contains an asteroid
                        self._evolve_existing_asteroid(x, y, avg, new_grid)
                    else:
                        # Empty cell
                        self._evolve_empty_cell(x, y, avg, new_grid)

            # Update the grid and generation counter
            self.automaton_grid = new_grid
            self.generation += 1

        # Call the parent update method
        super().update(delta_time)
```